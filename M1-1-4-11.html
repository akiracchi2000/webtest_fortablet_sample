<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>第4節-11 絶対値を含む式のグラフ</title>

    <!-- Katex -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <!-- html2canvas -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

    <!-- クイズデータ読み込み -->
    <script src="M1-1-4-11QD.js"></script>

    <!-- クイズデータ読み込み -->
    <script src="M1-1-4-11QD.js"></script>
    <script src="M1-1-4-11_images.js"></script>

    <script>
        // --- キャンバス画像をBase64取得（白紙チェック・クロップ・グレースケール） ---
        function getCanvasImageBase64(scale = 1) {
            if (!canvas) return null;

            // 作業用キャンバスを作成
            const workCanvas = document.createElement('canvas');
            workCanvas.width = canvas.width;
            workCanvas.height = canvas.height;
            const wCtx = workCanvas.getContext('2d', { willReadFrequently: true });

            // 1. 白背景で塗りつぶす (透明な部分を白にする)
            wCtx.fillStyle = '#ffffff';
            wCtx.fillRect(0, 0, workCanvas.width, workCanvas.height);

            // 2. 元のキャンバスを描画
            wCtx.drawImage(canvas, 0, 0);

            // 3. ピクセルデータを取得して「描画範囲」を特定 (クロップ用)
            //    同時にグレースケール化＆コントラスト強調もしてしまっても良いが、
            //    まずはクロップ座標を計算する。
            const imgData = wCtx.getImageData(0, 0, workCanvas.width, workCanvas.height);
            const data = imgData.data;
            let minX = workCanvas.width, minY = workCanvas.height, maxX = 0, maxY = 0;
            let hasDrawing = false;

            // 背景色判定用 (白かどうか)
            // 多少の誤差やアンチエイリアスを考慮し、完全に255でなくても「ほぼ白」なら無視
            const THRESHOLD = 240;

            for (let y = 0; y < workCanvas.height; y++) {
                for (let x = 0; x < workCanvas.width; x++) {
                    const i = (y * workCanvas.width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    // 「黒っぽい」ピクセルがあれば描画とみなす
                    // (R, G, Bがいずれも閾値を下回る場合など)
                    if (r < THRESHOLD || g < THRESHOLD || b < THRESHOLD) {
                        if (x < minX) minX = x;
                        if (x > maxX) maxX = x;
                        if (y < minY) minY = y;
                        if (y > maxY) maxY = y;
                        hasDrawing = true;
                    }
                }
            }

            if (!hasDrawing) {
                // 白紙の場合はそのまま返すか、特定のフラグを立てるが、
                // ここでは「全体」を返してしまう（checkAnswer側で白紙チェックしてもよい）
                return workCanvas.toDataURL('image/png').split(',')[1];
            }

            // マージンを追加
            const PADDING = 20;
            minX = Math.max(0, minX - PADDING);
            minY = Math.max(0, minY - PADDING);
            maxX = Math.min(workCanvas.width, maxX + PADDING);
            maxY = Math.min(workCanvas.height, maxY + PADDING);

            const cropW = maxX - minX;
            const cropH = maxY - minY;

            // 4. クロップした画像を生成
            const cropCanvas = document.createElement('canvas');
            cropCanvas.width = cropW;
            cropCanvas.height = cropH;
            const cCtx = cropCanvas.getContext('2d');

            // 白背景
            cCtx.fillStyle = '#ffffff';
            cCtx.fillRect(0, 0, cropW, cropH);

            // 切り抜き描画
            cCtx.drawImage(workCanvas, minX, minY, cropW, cropH, 0, 0, cropW, cropH);

            // 5. 最終的な画像データを取得
            //    (AIが見やすいようにグレースケール化や2値化をしても良いが、
            //     Geminiはカラー画像でも読めるので、コントラストだけ確保されていればOK)
            return cropCanvas.toDataURL('image/png').split(',')[1];
        }
    </script>

    <style>
        /* 共通スタイル */
        :root {
            --bg-color: #f0f2f5;
            --text-color: #333;
            --panel-bg: #ffffff;
            --border-color: #ccc;
            --header-bg: #007bff;
            --header-text: #fff;
            --btn-bg: #fff;
            --btn-text: #333;
            --btn-hover: #dee2e6;
            --btn-active-bg: #007bff;
            --btn-active-text: #fff;
            --memo-bg: #ffffff;
            --overlay-bg: rgba(255, 255, 255, 0.9);
            --correct-color: #007bff;
            --incorrect-color: #dc3545;
            --correct-bg: #d4edda;
            --incorrect-bg: #f8d7da;
            --link-color: #007bff;
        }

        body.dark-mode {
            --bg-color: #121212;
            --text-color: #e0e0e0;
            --panel-bg: #1e1e1e;
            --border-color: #444;
            --header-bg: #1a1a1a;
            --header-text: #e0e0e0;
            --btn-bg: #2d2d2d;
            --btn-text: #e0e0e0;
            --btn-hover: #3d3d3d;
            --btn-active-bg: #bb86fc;
            --btn-active-text: #000;
            --memo-bg: #121212;
            --overlay-bg: rgba(30, 30, 30, 0.9);
            --correct-color: #66b0ff;
            --incorrect-color: #ff6b6b;
            --correct-bg: #1e4620;
            --incorrect-bg: #4c1d1d;
            --link-color: #8ab4f8;
        }

        html,
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            display: flex;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
            overscroll-behavior: none;
            touch-action: none;
            transition: background-color 0.3s, color 0.3s;
        }

        /* --- 左パネル（クイズ） --- */
        #left-panel {
            flex: 0 0 50vw;
            width: 50vw;
            height: 100%;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            background-color: var(--panel-bg);
            transition: background-color 0.3s;
            overscroll-behavior: none;
            touch-action: pan-y;
            border-right: none;
        }

        /* --- リサイザー（境界線） --- */
        #resizer {
            width: 10px;
            background-color: var(--border-color);
            cursor: col-resize;
            z-index: 100;
            touch-action: none;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s;
        }

        #resizer:hover,
        #resizer.active {
            background-color: #007bff;
        }

        #resizer::after {
            content: "⋮";
            color: #666;
            font-size: 1.2em;
            font-weight: bold;
        }

        /* --- 右パネル（メモパッド） --- */
        #right-panel {
            flex: 0 0 50vw;
            width: 50vw;
            height: 100%;
            padding: 0;
            box-sizing: border-box;
            overflow: hidden;
            /* スクロールバーによる余白防止 */
            background-color: var(--panel-bg);
            transition: background-color 0.3s;
            position: relative;
            display: flex;
            flex-direction: column;
            touch-action: none;
            overscroll-behavior: none;
        }

        #memo-toolbar {
            height: 50px;
            background: var(--panel-bg);
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 0 15px;
            border-top: 1px solid var(--border-color);
            padding-bottom: env(safe-area-inset-bottom);
            height: auto;
            min-height: 50px;
            touch-action: manipulation;
            transition: background-color 0.3s, border-color 0.3s;
        }

        #memo-container {
            flex: 1;
            position: relative;
            cursor: crosshair;
            background: var(--memo-bg);
            /* 変数を使用 */
            margin: 0;
            border-radius: 0;
            box-shadow: none;
            overflow: hidden;
            touch-action: none;
            transition: background-color 0.3s;
        }

        #memo-pad {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        #memo-question-overlay {
            position: absolute;
            top: calc(10px + env(safe-area-inset-top));
            left: 10px;
            right: 10px;
            background: var(--overlay-bg);
            color: var(--text-color);
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            pointer-events: none;
            /* ペン入力を邪魔しないように */
            display: none;
            z-index: 10;
            font-size: 0.9em;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }

        #eraser-cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid #555;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            pointer-events: none;
            display: none;
            transform: translate(-50%, -50%);
            z-index: 20;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
        }

        .tool-btn {
            background: var(--btn-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 0.9em;
            color: var(--btn-text);
            touch-action: manipulation;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }

        .tool-btn:hover:not(:disabled) {
            background: var(--btn-hover);
        }

        .tool-btn.active {
            background: var(--btn-active-bg);
            color: var(--btn-active-text);
            border-color: var(--btn-active-bg);
        }

        /* --- クイズ用スタイル (既存のスタイルを調整) --- */
        header {
            background-color: var(--header-bg);
            color: var(--header-text);
            padding: 10px;
            text-align: center;
            border-radius: 5px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.3s, color 0.3s;
        }

        header h1 {
            margin: 0;
            color: inherit;
            /* 親要素のcolorを継承 */
            font-size: 1.5em;
        }

        #quiz-container {
            min-height: 300px;
        }

        #progress-bar {
            width: 100%;
            height: 10px;
            background-color: var(--border-color);
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 15px;
            transition: background-color 0.3s;
        }

        #progress {
            width: 0%;
            height: 100%;
            background-color: #007bff;
            transition: width 0.3s ease-in-out;
        }

        #question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        #question-number {
            font-weight: bold;
            color: #007bff;
        }

        #score {
            font-weight: bold;
            color: #28a745;
        }

        #question-text {
            font-size: 1.2em;
            margin: 15px 0 25px 0;
            color: var(--text-color);
            transition: color 0.3s;
        }

        #options-container {
            display: none;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 20px;
        }

        #options-container.options-vertical {
            grid-template-columns: 1fr;
            gap: 10px;
        }

        .option-btn {
            padding: 15px;
            border: 2px solid var(--border-color);
            border-radius: 5px;
            background-color: var(--panel-bg);
            cursor: pointer;
            font-size: 1.0em;
            transition: all 0.3s;
            width: 100%;
            text-align: left;
            color: var(--text-color);
            touch-action: manipulation;
        }

        .option-btn:hover:not(:disabled) {
            background-color: var(--btn-hover);
            border-color: #007bff;
        }

        .option-btn:disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }

        .option-btn.correct {
            background-color: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
            font-weight: bold;
        }

        .option-btn.incorrect {
            background-color: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }

        .option-btn.incorrect.selected {
            opacity: 1;
            border-width: 3px;
        }

        #show-options-btn {
            display: none;
            margin: 20px auto;
            padding: 12px 30px;
            font-size: 1.1em;
            font-weight: bold;
            color: #fff;
            background-color: #17a2b8;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #show-options-btn:hover {
            background-color: #138496;
        }

        #feedback {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            display: none;
            border: 2px solid;
            background-color: var(--panel-bg);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }

        #feedback.correct-feedback {
            background-color: var(--correct-bg);
            border-color: var(--correct-color);
            color: var(--text-color);
        }

        #feedback.incorrect-feedback {
            background-color: var(--incorrect-bg);
            border-color: var(--incorrect-color);
            color: var(--text-color);
        }

        .close-modal:hover,
        .close-modal:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        /* リンクのスタイル */
        a {
            color: var(--link-color);
        }

        .speak-button {
            display: none;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2em;
            margin-left: 8px;
            padding: 2px 5px;
        }

        #next-btn,
        #results-btn {
            display: none;
            padding: 12px 25px;
            font-size: 1.1em;
            font-weight: bold;
            color: #fff;
            background-color: #007bff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            float: right;
            margin-top: 20px;
            transition: background-color 0.3s;
            touch-action: manipulation;
        }

        #next-btn:hover,
        #results-btn:hover {
            background-color: #0056b3;
        }

        #results-container {
            text-align: center;
            font-size: 1.4em;
            display: none;
            color: var(--text-color);
            transition: color 0.3s;
        }

        #results-container h2 {
            color: #007bff;
        }

        #homepage-link {
            display: inline-block;
            margin-top: 20px;
            padding: 12px 20px;
            background-color: #6c757d;
            color: #fff;
            text-decoration: none;
            border-radius: 5px;
            font-size: 1.1em;
        }

        #homepage-link:hover {
            background-color: #5a6268;
        }

        /* AI分析ボタン */
        .ai-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            border: none;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            margin-top: 10px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .ai-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(118, 75, 162, 0.4);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
        }

        /* AIバナー（ヘッダー用） */
        .ai-banner {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            display: inline-block;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            margin-bottom: 10px;
        }

        .explanation-banner {
            background: linear-gradient(135deg, #28a745 0%, #218838 100%);
            color: #fff;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            display: inline-block;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            margin-bottom: 10px;
        }

        /* モーダル */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: var(--panel-bg);
            padding: 20px;
            border-radius: 12px;
            width: 80%;
            max-width: 600px;
            max-height: 80vh;
            max-height: 80vh;
            overflow-y: auto;
            overscroll-behavior: none;
            touch-action: pan-y;
            text-align: left;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            position: relative;
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }

        .close-modal {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 1.5em;
            cursor: pointer;
            color: #999;
        }

        /* Image Preview Modal */
        #image-preview-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #image-preview-modal img {
            max-width: 90%;
            max-height: 70%;
            border: 2px solid #fff;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            margin-bottom: 20px;
        }

        #image-preview-modal .modal-controls {
            display: flex;
            gap: 15px;
        }

        #image-preview-modal button {
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            transition: background 0.3s;
            touch-action: manipulation;
        }

        #image-preview-modal .close-btn {
            background: #6c757d;
            color: #fff;
        }

        #image-preview-modal .share-btn {
            background: #007bff;
            color: #fff;
        }

        #image-preview-modal .save-hint {
            color: #fff;
            margin-bottom: 15px;
            font-size: 1em;
            text-align: center;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 4px;
        }

        /* ===== 追加：不正解時の2択（やり直す／正解を教えて） ===== */
        .wrong-decision-area {
            margin-top: 12px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .wrong-decision-btn {
            padding: 10px 18px;
            font-size: 1em;
        }

        .wrong-decision-note {
            margin-top: 8px;
            font-size: 0.85em;
            opacity: 0.8;
            text-align: center;
        }

        /* ===== 追加：励ましコメント（気持ちよさUP） ===== */

        #encouragement-under-question {
            margin: 12px auto 0 auto;
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px dashed var(--border-color);
            background: var(--panel-bg);
            font-size: 0.98em;
            text-align: center;
            max-width: 95%;
            opacity: 0.92;
        }

        /* --- グラフ作成ツール用スタイル (追加) --- */
        #btn-graph {
            display: none;
            /* 初期状態は非表示 */
        }

        #btn-graph.active {
            background-color: #6610f2;
            color: white;
            border-color: #6610f2;
            box-shadow: 0 0 0 0.2rem rgba(102, 16, 242, 0.5);
        }

        .graph-guide {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(40, 40, 40, 0.9);
            color: #fff;
            padding: 8px 16px;
            border-radius: 20px;
            pointer-events: none;
            display: none;
            z-index: 100;
            font-weight: bold;
            font-size: 0.9em;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            white-space: nowrap;
        }

        /* ページコントロール */
        #page-controls {
            position: static;
            transform: none;
            margin-right: auto;
            /* 左寄せ */
            display: flex;
            align-items: center;
            gap: 15px;
            color: var(--text-color);
            font-weight: bold;
            font-size: 1.1em;
            z-index: 5;
        }

        .page-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2em;
            color: var(--btn-text);
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .page-btn:hover:not(:disabled) {
            background: var(--btn-hover);
        }

        .page-btn:disabled {
            opacity: 0.3;
            cursor: default;
        }
    </style>
</head>

<body>

    <!-- 左パネル：クイズ -->
    <div id="left-panel">
        <header>
            <h1>第4節-11 絶対値を含む式のグラフ</h1>
            <div>
                <!-- <button id="fullscreen-toggle" class="tool-btn" onclick="toggleFullscreen()"
                    style="padding: 5px 10px; font-size: 1.2em;" title="フルスクリーン／フルスクリーン解除">?</button> -->
                <button id="dark-mode-toggle" class="tool-btn" onclick="toggleDarkMode()"
                    style="padding: 5px 10px; font-size: 1.2em;" title="ダークモード／ライトモード">🌙</button>
                <button id="resume-toggle" class="tool-btn" onclick="toggleResume()"
                    style="padding: 5px 10px; font-size: 1.2em; display: none;" title="途中保存機能のON/OFF">📂</button>
                <button id="sound-toggle" class="tool-btn" onclick="toggleSound()"
                    style="padding: 5px 10px; font-size: 1.2em;" title="効果音の有／無">🔊</button>
            </div>
        </header>
        <main>
            <div id="quiz-container">
                <div id="progress-bar">
                    <div id="progress"></div>
                </div>
                <div id="question-header">
                    <span id="question-number"></span>
                    <span id="score"></span>
                </div>
                <h2 id="question-text"></h2>

                <div id="encouragement-under-question" style="display:none;"></div>

                <button id="answer-btn" class="tool-btn ai-btn"
                    style="display:block; margin: 20px auto; padding: 12px 30px; font-size: 1.2em;"
                    onclick="checkAnswerWithAI()">🤖AIカガワ先生🤖に添削してもらう</button>
                <div id="analyzing-indicator" style="display:none; text-align:center; margin: 10px 0;">
                    <span style="font-size: 2em;">🤖</span> 採点中...
                </div>

                <div id="options-container" style="display:none;"></div>

                <div id="feedback"></div>

                <button id="next-btn">次の問題へ</button>
                <button id="results-btn">結果を見る</button>
            </div>

            <div id="results-container">
                <h2>テスト終了！</h2>
                <p id="score-text"></p>
                <p id="final-message"></p>

                <!-- 結果送信フォーム -->
                <!-- 結果送信フォーム -->
                <div
                    style="margin: 20px 0; padding: 15px; background: var(--panel-bg); border-radius: 8px; border: 1px solid var(--border-color);">
                    <p style="margin-bottom: 10px; font-size: 0.9em;">※名前とGAS URLはトップページで設定してください。</p>
                    <button class="tool-btn" onclick="sendResults()" style="background-color: #28a745; color: white;">📤
                        先生に送信</button>
                    <p id="send-status" style="margin-top: 5px; font-size: 0.9em; color: var(--text-color);"></p>
                </div>

                <button id="retry-btn" style="display:none; margin: 10px auto; background-color: #ffc107; color: #000;"
                    class="tool-btn" onclick="retryIncorrect()">🔥 間違えた問題だけリトライ</button>
                <br>
                <a href="index.html" id="homepage-link">トップページに戻る</a>
            </div>
        </main>
        <footer>
            <p>&copy; 2025 [香川亮]</p>
        </footer>
    </div>

    <!-- リサイザー -->
    <div id="resizer"></div>

    <!-- 右パネル：メモパッド -->
    <div id="right-panel">
        <div id="memo-container">
            <div id="memo-question-overlay"></div>
            <div id="graph-guide" class="graph-guide">頂点などをタップしてプロットしてください</div>
            <div id="eraser-cursor"></div>
            <canvas id="memo-pad"></canvas>
        </div>
        <div id="memo-toolbar">
            <div id="page-controls">
                <button id="prev-page-btn" class="page-btn" onclick="switchPage(-1)">◀</button>
                <span id="page-indicator">1 / 1</span>
                <button id="next-page-btn" class="page-btn" onclick="switchPage(1)">▶</button>
            </div>
            <button class="tool-btn active" id="btn-pen" onclick="setTool('pen')">✏️ ペン</button>
            <button class="tool-btn" id="btn-pen-red" onclick="setTool('pen-red')">🔴 赤ペン</button>
            <button class="tool-btn" id="btn-eraser" onclick="setTool('eraser')">🧽 消しゴム</button>
            <button id="btn-graph" class="tool-btn" onclick="setTool('graph')" title="グラフ作成"
                style="display: inline-block;">📈 グラフ</button>
            <button class="tool-btn active" id="btn-pen-only" onclick="togglePenOnly()">🖊️ ペンのみ</button>
            <button class="tool-btn" onclick="undoMemo()">↩️ 元に戻す</button>
            <span style="margin: 0 10px; color: #ccc;">|</span>
            <button class="tool-btn" id="btn-toggle-question" onclick="toggleQuestionOverlay()">📖 問題を表示</button>
            <button class="tool-btn" onclick="saveMemo()">💾 画像保存</button>
            <button class="tool-btn" onclick="clearMemo()">🗑️ メモを消去</button>
        </div>
    </div>

    <!-- AI分析モーダル -->
    <div id="ai-modal" class="modal-overlay">
        <div class="modal-content">
            <span class="close-modal" onclick="closeAiModal()">&times;</span>
            <h3>🤖 AIカガワ先生の分析</h3>
            <div id="ai-content">
                <p>分析中...</p>
            </div>
        </div>
    </div>

    <script>
        // --- グローバル変数 ---
        let quizData = [];
        let incorrectQuestions = []; // 間違えた問題を格納
        let currentQuestionIndex = 0;
        let score = 0;
        let startTime; // 開始時間
        let isSoundOn = true; // 効果音ON/OFF
        let isDarkMode = false; // ダークモードON/OFF
        let isResumeOn = false; // レジューム機能ON/OFF (デフォルトOFF)
        let currentPenColor = '#000'; // 現在のペンの色
        const synth = window.speechSynthesis;
        let currentUtterance = null;
        let audioCtx = null; // グローバルAudioContext

        // --- キャンバス関連 ---
        // --- AIのJSONを安全にパース（\subset などの不正エスケープを自動修復） ---
        function parseAIJsonWithRepair(rawText) {
            if (!rawText) throw new Error("Empty AI response");

            const trimmed = rawText.trim();

            // 余計な前後文が混ざっても最初の { から最後の } を拾う
            const match = trimmed.match(/\{[\s\S]*\}/);
            let jsonStr = match ? match[0] : trimmed;

            // まず素直にパース
            try {
                return JSON.parse(jsonStr);
            } catch (e1) {
                // JSONとして無効なバックスラッシュだけを \\ に修復
                // 例: "\subset" -> "\\subset"
                let repaired = jsonStr.replace(
                    /\\(?!["\\/bfnrtu]|u[0-9a-fA-F]{4})/g,
                    '\\\\'
                );

                try {
                    return JSON.parse(repaired);
                } catch (e2) {
                    // 最終保険：全部の \ を \\ に（多少荒いが止血になる）
                    repaired = jsonStr.replace(/\\/g, '\\\\');
                    return JSON.parse(repaired);
                }
            }
        }

        const canvas = document.getElementById('memo-pad');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        let isDrawing = false;
        let currentTool = 'pen'; // 'pen' or 'eraser'
        let memoHistory = []; // Undo用履歴
        let isPenOnlyMode = true; // ペンのみモード（パームリジェクション）
        let graphPlotter = null; // グローバル GraphPlotter インスタンス
        let multiPageManager = null; // グローバル MultiPageManager インスタンス

        // --- MultiPageManager ---
        class MultiPageManager {
            constructor(canvas, ctx) {
                this.canvas = canvas;
                this.ctx = ctx;
                this.pages = []; // { imageData: ImageData, graphPoints: [] }
                this.currentPageIndex = 0;
                this.totalPages = 2; // 最大ページ数

                // 初期ページ確保
                for (let i = 0; i < this.totalPages; i++) {
                    this.pages.push({ imageData: null, graphPoints: [] });
                }

                this.initUI();
                // 初期ページ（ページ1）をロードして状態を確定させる
                this.loadPage(0);
            }

            initUI() {
                this.updatePageControls();
            }

            saveCurrentPage() {
                // 現在のキャンバス状態を保存
                this.pages[this.currentPageIndex].imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                // グラフデータも保存
                if (window.graphPlotter) {
                    this.pages[this.currentPageIndex].graphPoints = [...window.graphPlotter.points];
                }
            }

            loadPage(index) {
                if (index < 0 || index >= this.totalPages) return;

                // 現在のページを保存してから移動
                this.saveCurrentPage();

                this.currentPageIndex = index;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                const page = this.pages[index];
                if (page.imageData) {
                    this.ctx.putImageData(page.imageData, 0, 0);
                }

                // グラフデータの復元
                if (window.graphPlotter) {
                    window.graphPlotter.points = [...page.graphPoints];
                    // グラフモードなら再描画
                    // ページに応じたツール切り替え
                    // ページに応じたツール切り替え
                    if (index === 0) {
                        if (typeof setTool === 'function') setTool('pen');
                        // 確実にグリッドを消去するためにリセット
                        if (window.graphPlotter) {
                            window.graphPlotter.deactivate();
                            // deactivateだけでは描画が残る可能性があるので、キャンバスをクリアしてImageDataだけ描く
                            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                            if (page.imageData) {
                                this.ctx.putImageData(page.imageData, 0, 0);
                            }
                        }
                    } else if (index === 1) {
                        if (typeof setTool === 'function') setTool('graph');
                    }

                    // ツール切り替えで再描画されるため、ここでの明示的な描画は不要（setTool('graph')がactivateを呼ぶ）
                    // ただし、ツール切り替え後に確実に反映させる意味で残しても良いが、重複描画になるため削除またはコメントアウト
                    // if (window.graphPlotter.isActive) { ... }
                }

                this.updatePageControls();

                // 履歴はページ移動でリセットするのが安全（複雑化回避）
                memoHistory = [];
            }

            updatePageControls() {
                const indicator = document.getElementById('page-indicator');
                const prev = document.getElementById('prev-page-btn');
                const next = document.getElementById('next-page-btn');

                if (indicator) indicator.textContent = `${this.currentPageIndex + 1} / ${this.totalPages}`;
                if (prev) prev.disabled = (this.currentPageIndex === 0);
                if (next) next.disabled = (this.currentPageIndex === this.totalPages - 1);
            }
        }

        // グローバル関数（HTMLから呼ぶ用）
        function switchPage(delta) {
            if (window.multiPageManager) {
                const newIndex = window.multiPageManager.currentPageIndex + delta;
                window.multiPageManager.loadPage(newIndex);
            }
        }



        document.addEventListener("DOMContentLoaded", function () {
            initAudioContext(); // オーディオコンテキストの初期化準備
            initCanvas();
            setTimeout(resizeCanvas, 100); // レイアウト確定後に再調整

            // --- クラスのインスタンス化 ---
            if (typeof MultiPageManager !== 'undefined' && typeof GraphPlotter !== 'undefined') {
                multiPageManager = new MultiPageManager(canvas, ctx);
                graphPlotter = new GraphPlotter(canvas, ctx);

                // HTMLのインラインイベントハンドラ等から参照できるようにwindowオブジェクトに紐付ける
                window.multiPageManager = multiPageManager;
                window.graphPlotter = graphPlotter;
            }

            initQuiz();
            // ダークモード設定を読み込む
            const savedDarkMode = localStorage.getItem('darkMode');
            if (savedDarkMode === 'true') {
                isDarkMode = true;
                document.body.classList.add('dark-mode');
                document.getElementById('dark-mode-toggle').textContent = '☀️';
                currentPenColor = '#fff'; // ペンの色を白に設定
            }

            // レジューム設定を読み込む (一時的に無効化)
            // const savedResume = localStorage.getItem('resumeOn');
            // if (savedResume !== null) {
            //     isResumeOn = (savedResume === 'true');
            // }
            updateResumeButton();

            // 全体スクロール防止（左パネルとモーダル以外）
            document.addEventListener('touchmove', function (e) {
                // 左パネル、モーダル、またはツールバー内の要素（ボタンなど）での操作は許可
                if (!e.target.closest('#left-panel') &&
                    !e.target.closest('.modal-content') &&
                    !e.target.closest('#image-preview-modal') && !e.target.closest('#memo-toolbar')) {
                    e.preventDefault();
                }
            }, { passive: false });

            // --- 積極的なオーディオプリロード（遅延対策） ---
            document.addEventListener('touchstart', function (e) {
                if (e.target.closest('.option-btn') || e.target.closest('#next-btn') || e.target.closest('#results-btn')) {
                    if (isSoundOn) {
                        try {
                            const AudioContext = window.AudioContext || window.webkitAudioContext;
                            if (!audioCtx && AudioContext) {
                                audioCtx = new AudioContext();
                            }
                            if (audioCtx && audioCtx.state === 'suspended') {
                                audioCtx.resume();
                            }
                        } catch (err) {
                            console.error("Audio warmup failed:", err);
                        }
                    }
                }
            }, { passive: true });
        });


        // --- クイズ初期化 ---
        function initQuiz() {
            // KaTeX設定
            const katexDelimiters = [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ];
            const renderMath = () => {
                if (window.renderMathInElement) {
                    renderMathInElement(document.body, { delimiters: katexDelimiters, throwOnError: false });
                } else {
                    setTimeout(renderMath, 100);
                }
            };
            renderMath();

            // データ読み込み (window.QUIZ_DATA from M1-1-1-1QD.js)
            let allData = [];
            if (window.QUIZ_DATA) {
                allData = window.QUIZ_DATA;
            } else if (typeof allQuizData !== 'undefined') {
                allData = allQuizData; // フォールバック
            }

            if (!allData || allData.length === 0) {
                document.getElementById('question-text').innerText = "問題データが見つかりません。";
                return;
            }

            // レジューム機能：保存されたデータがあるか確認
            const urlParams = new URLSearchParams(window.location.search);
            const isReset = urlParams.get('reset') === 'true';

            if (isReset) {
                // index.htmlから来た場合などはリセット（確認なしで最初から）
                // URLからパラメータを削除して、リロード時はレジュームが効くようにする
                const newUrl = window.location.pathname + window.location.hash;
                window.history.replaceState(null, '', newUrl);
            } else if (isResumeOn) {
                const savedData = localStorage.getItem('quiz_progress_M1-1-4-11');
                if (savedData) {
                    if (confirm("前回の続きから始めますか？")) {
                        restoreProgress(JSON.parse(savedData));
                        return;
                    } else {
                        localStorage.removeItem('quiz_progress_M1-1-4-11'); // キャンセルしたら削除
                    }
                }
            }

            // シャッフルして10問抽出
            const shuffled = [...allData].sort(() => 0.5 - Math.random());
            quizData = shuffled.slice(0, 10);

            startTime = Date.now(); // タイマー開始
            loadQuestion();


        }



        // --- クイズロジック ---
        function loadQuestion() {
            const quizContainer = document.getElementById('quiz-container');
            const resultsContainer = document.getElementById('results-container');
            const feedbackEl = document.getElementById('feedback');
            const nextBtn = document.getElementById('next-btn');
            const resultsBtn = document.getElementById('results-btn');
            const optionsContainer = document.getElementById('options-container');
            const showOptionsBtn = document.getElementById('show-options-btn');
            const questionNumberEl = document.getElementById('question-number');
            const questionTextEl = document.getElementById('question-text');

            if (currentQuestionIndex >= quizData.length) return;

            // リセット
            feedbackEl.style.display = 'none';
            nextBtn.style.display = 'none';
            resultsBtn.style.display = 'none';
            document.getElementById('answer-btn').style.display = 'block';
            document.getElementById('analyzing-indicator').style.display = 'none';

            // メモは消さない（ユーザーが前の計算を残したいかもしれないので）
            clearMemo();

            // メモの「問題を表示」をリセット
            document.getElementById('memo-question-overlay').style.display = 'none';
            document.getElementById('btn-toggle-question').classList.remove('active');

            updateProgressAndScore();
            saveProgress(); // 進行状況を保存



            const currentQuestion = quizData[currentQuestionIndex];
            questionNumberEl.textContent = `問題 ${currentQuestionIndex + 1} / ${quizData.length}`;
            questionTextEl.innerHTML = currentQuestion.question;

            // メモパッド上の問題文更新
            document.getElementById('memo-question-overlay').innerHTML = `<strong>問題 ${currentQuestionIndex + 1}:</strong><br>${currentQuestion.question}`;

            renderAllMath();
        }


        // --- 不正解時の分岐（もう一度解く／正解を教えて） ---
        let pendingAIResult = null; // { questionIndex, recognizedAnswer, feedback }

        // --- 励ましコメント（気持ちよさUP） ---
        const ENCOURAGEMENTS = [
            "OK！今の気づきを活かしてもう一度いこう。",
            "ナイス判断。ここでやり直せるのが強い。",
            "大丈夫。1回目で気づけたのが収穫！",
            "落ち着いていけば必ず取れる。",
            "今のミスは伸びしろ。次で回収しよう。",
            "いいね。ここからが本番。",
            "書き直してみよう。答えに近づいてるよ。"
        ];

        function showEncouragement() {
            const el = document.getElementById("encouragement-under-question");
            if (!el) return;
            const msg = ENCOURAGEMENTS[Math.floor(Math.random() * ENCOURAGEMENTS.length)];
            el.textContent = msg;
            el.style.display = "block";
        }
        function hideEncouragement() {
            const el = document.getElementById("encouragement-under-question");
            if (!el) return;
            el.style.display = "none";
        }

        // --- GraphPlotter Class ---
        class GraphPlotter {
            constructor(canvas, ctx) {
                this.canvas = canvas;
                this.ctx = ctx;
                this.isActive = false;
                this.points = []; // {x, y} (論理座標)
                this.gridSize = 40; // 1目盛りのピクセル数
                this.snapThreshold = 20; // ピクセル単位のスナップ距離
                this.hoverPoint = null; // スナップ候補の点
                this.history = []; // 履歴
            }

            activate() {
                // ページ2（インデックス1）以外ではアクティブにしない
                if (window.multiPageManager && window.multiPageManager.currentPageIndex !== 1) {
                    return;
                }

                this.isActive = true;
                this.origin = { x: this.canvas.width / 2, y: this.canvas.height / 2 };
                this.drawGrid();
                this.drawPointsAndLines();
                const guide = document.getElementById('graph-guide');
                if (guide) guide.style.display = 'block';
            }

            deactivate() {
                this.isActive = false;
                this.hoverPoint = null;
                const guide = document.getElementById('graph-guide');
                if (guide) guide.style.display = 'none';
            }

            reset() {
                this.points = [];
                this.history = [];
                this.hoverPoint = null;
            }

            saveData() {
                return {
                    points: [...this.points],
                    isActive: this.isActive
                };
            }

            loadData(data) {
                if (!data) return;
                this.points = data.points || [];
                if (this.isActive) {
                    this.drawGrid();
                    this.drawPointsAndLines();
                }
            }

            handleMove(x, y) {
                if (!this.isActive) return;

                const logical = this.toLogical(x, y);
                const snapped = {
                    x: Math.round(logical.x),
                    y: Math.round(logical.y)
                };
                const phys = this.toPhysical(snapped.x, snapped.y);
                const dist = Math.sqrt((x - phys.x) ** 2 + (y - phys.y) ** 2);

                if (dist <= this.snapThreshold) {
                    // 同じ座標かチェック（浮動小数点の誤差は丸めているのでOK）
                    if (!this.hoverPoint || this.hoverPoint.x !== snapped.x || this.hoverPoint.y !== snapped.y) {
                        this.hoverPoint = snapped;
                        this.drawGrid();
                        this.drawPointsAndLines();
                    }
                } else {
                    if (this.hoverPoint) {
                        this.hoverPoint = null;
                        this.drawGrid();
                        this.drawPointsAndLines();
                    }
                }
            }

            handleTap(x, y) {
                if (!this.isActive) return false;

                // スナップ処理 (handleMoveと同じロジックを利用)
                let targetPoint = null;

                // ホバー中ならその点を使う
                if (this.hoverPoint) {
                    targetPoint = { ...this.hoverPoint };
                } else {
                    // ホバーしていなくても、クリック時は強制的に最寄りの格子点にスナップする
                    // 要望: "プロットは、近い格子点になるとスナップする仕様がいい"
                    // -> クリック時はユーザーは「そこに近い点」を意図しているはずなので、
                    // 距離による厳密なフィルタ（デッドゾーン作成）は排除し、最寄りの点採用する。
                    const logical = this.toLogical(x, y);
                    const snapped = {
                        x: Math.round(logical.x),
                        y: Math.round(logical.y)
                    };
                    // 念のため、あまりにも遠すぎる（画面外のような）誤タップを防ぐ閾値は設けるが、
                    // グリッドサイズ(40)よりも大きく取る
                    const phys = this.toPhysical(snapped.x, snapped.y);
                    const dist = Math.sqrt((x - phys.x) ** 2 + (y - phys.y) ** 2);

                    if (dist <= this.gridSize * 1.5) { // 60px以内なら許容
                        targetPoint = snapped;
                    } else {
                        return false;
                    }
                }

                // 範囲チェック (例: -10 ~ 10)
                if (Math.abs(targetPoint.x) > 15 || Math.abs(targetPoint.y) > 15) return false;

                // 既存の点に近いかチェック -> 削除
                const existingIndex = this.points.findIndex(p => p.x === targetPoint.x && p.y === targetPoint.y);

                this.saveHistory(); // 変更前に履歴保存

                if (existingIndex >= 0) {
                    this.points.splice(existingIndex, 1);
                } else {
                    this.points.push(targetPoint);
                }

                // 再描画
                this.drawGrid();
                this.drawPointsAndLines();

                return true; // 処理したのでペンの描画をキャンセルさせる
            }

            saveHistory() {
                if (this.history.length >= 20) this.history.shift();
                this.history.push(this.points.map(p => ({ ...p })));
            }

            undo() {
                if (this.history.length > 0) {
                    this.points = this.history.pop();
                    this.drawGrid();
                    this.drawPointsAndLines();
                }
            }

            drawGrid() {
                const { width, height } = this.canvas;
                const ox = this.origin.x;
                const oy = this.origin.y;
                const gs = this.gridSize;

                const gCtx = this.ctx;
                gCtx.save();
                gCtx.beginPath();

                // 背景は透明のまま描画しない (元のCanvas内容を保持するか、クリアするかは要検討)
                // メモパッドなので背景は既に描画されているはず。
                // ただし、グリッドを再描画するなら一旦クリアが必要かも。
                // ここではメモ内容（手書き）とグリッドが混在するため、
                // 本当はレイヤー分けが必要だが、簡易実装として「手書き」の上に「グリッド」を描くと手書きが消える？
                // いえ、drawGridは最初に呼ばれるべき。
                // 簡易実装: 全クリアしてしまうと手書きが消えるが、グラフモードはグラフモードで独立した描画と考え、
                // 毎回クリアして再描画するアプローチをとる。
                gCtx.clearRect(0, 0, width, height);
                // 背景白 (ダークモードなら黒が良いが、とりあえずCSSに従うなら透明でよいはずだが、線が見えない件の対応)

                // ★修正: ユーザー設定の色を使用
                gCtx.fillStyle = isDarkMode ? '#121212' : '#ffffff';
                gCtx.fillRect(0, 0, width, height);

                gCtx.strokeStyle = isDarkMode ? '#444' : '#e0e0e0';
                gCtx.lineWidth = 1;

                // 縦線
                for (let x = ox % gs; x < width; x += gs) {
                    gCtx.moveTo(x, 0);
                    gCtx.lineTo(x, height);
                }
                // 横線
                for (let y = oy % gs; y < height; y += gs) {
                    gCtx.moveTo(0, y);
                    gCtx.lineTo(width, y);
                }
                gCtx.stroke();

                // 軸
                gCtx.beginPath();
                gCtx.strokeStyle = isDarkMode ? '#888' : '#888';
                gCtx.lineWidth = 2;
                gCtx.moveTo(0, oy);
                gCtx.lineTo(width, oy); // X軸
                gCtx.moveTo(ox, 0);
                gCtx.lineTo(ox, height); // Y軸
                gCtx.stroke();

                gCtx.restore();
            }

            drawPointsAndLines() {
                if (this.points.length === 0 && !this.hoverPoint) return;

                // X座標でソート
                const sortedPoints = [...this.points].sort((a, b) => a.x - b.x);

                const gCtx = this.ctx;
                gCtx.save();

                // 線 (点が2つ以上ある場合のみ)
                if (sortedPoints.length >= 2) {
                    gCtx.beginPath();
                    gCtx.strokeStyle = '#007bff';
                    gCtx.lineWidth = 3;

                    const start = this.toPhysical(sortedPoints[0].x, sortedPoints[0].y);
                    gCtx.moveTo(start.x, start.y);

                    for (let i = 1; i < sortedPoints.length; i++) {
                        const p = this.toPhysical(sortedPoints[i].x, sortedPoints[i].y);
                        gCtx.lineTo(p.x, p.y);
                    }
                    gCtx.stroke();
                }

                // 点
                gCtx.fillStyle = '#ff0000';
                gCtx.font = 'bold 12px sans-serif'; // フォント設定
                gCtx.textBaseline = 'bottom'; // 下揃えにして点の上に表示

                for (let p of sortedPoints) {
                    const phys = this.toPhysical(p.x, p.y);
                    gCtx.beginPath();
                    gCtx.arc(phys.x, phys.y, 5, 0, Math.PI * 2);
                    gCtx.fillStyle = '#ff0000'; // 点の色
                    gCtx.fill();

                    // ★確定した点の座標表示
                    const coordText = `(${p.x}, ${p.y})`;
                    // 点の少し右上に表示
                    gCtx.fillText(coordText, phys.x + 8, phys.y - 8);
                }

                // ホバー（ゴースト）ポイント
                if (this.hoverPoint) {
                    const hp = this.toPhysical(this.hoverPoint.x, this.hoverPoint.y);
                    gCtx.beginPath();
                    gCtx.fillStyle = 'rgba(255, 0, 0, 0.4)'; // 半透明の赤
                    gCtx.arc(hp.x, hp.y, 8, 0, Math.PI * 2);
                    gCtx.fill();
                    // 枠線もつけると見やすいかも
                    gCtx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                    gCtx.lineWidth = 1;
                    gCtx.stroke();

                    // ★座標のツールチップ表示
                    const coordText = `(${this.hoverPoint.x}, ${this.hoverPoint.y})`;
                    gCtx.font = 'bold 14px sans-serif';
                    const tm = gCtx.measureText(coordText);
                    const pad = 4;
                    const boxW = tm.width + pad * 2;
                    const boxH = 20;
                    const boxX = hp.x + 10;
                    const boxY = hp.y - 30;

                    // 背景ボックス
                    gCtx.fillStyle = isDarkMode ? 'rgba(50, 50, 50, 0.9)' : 'rgba(255, 255, 255, 0.9)';
                    gCtx.fillRect(boxX, boxY, boxW, boxH);
                    gCtx.strokeStyle = isDarkMode ? '#aaa' : '#666';
                    gCtx.strokeRect(boxX, boxY, boxW, boxH);

                    // テキスト
                    gCtx.fillStyle = isDarkMode ? '#fff' : '#000';
                    gCtx.textBaseline = 'middle';
                    gCtx.fillText(coordText, boxX + pad, boxY + boxH / 2);
                }

                gCtx.restore();
            }

            toLogical(px, py) {
                return {
                    x: (px - this.origin.x) / this.gridSize,
                    y: -(py - this.origin.y) / this.gridSize // Yは上が正
                };
            }

            toPhysical(lx, ly) {
                return {
                    x: this.origin.x + lx * this.gridSize,
                    y: this.origin.y - ly * this.gridSize
                };
            }
        }


        function showWrongDecisionUI(currentQuestion, result) {
            const feedbackEl = document.getElementById('feedback');
            const nextBtn = document.getElementById('next-btn');
            const resultsBtn = document.getElementById('results-btn');
            const answerBtn = document.getElementById('answer-btn');

            nextBtn.style.display = 'none';
            resultsBtn.style.display = 'none';
            answerBtn.style.display = 'none';

            pendingAIResult = {
                questionIndex: currentQuestionIndex,
                recognizedAnswer: result.recognizedAnswer || '',
                feedback: result.feedback || ''
            };

            feedbackEl.className = 'incorrect-feedback';
            feedbackEl.innerHTML = `
                <div class="ai-banner">🤖AIカガワ先生🤖の解答check✅</div><br>
                <span style="color: var(--incorrect-color);"><strong>今回は不正解でした。</strong></span><br>
                あなたの解答: ${pendingAIResult.recognizedAnswer || '(読み取り不可)'}<br>
                <div class="wrong-decision-area">
                    <button class="tool-btn ai-btn wrong-decision-btn" onclick="retryCurrentQuestion()">🔁 もう一度解く</button>
                    <button class="tool-btn ai-btn wrong-decision-btn" onclick="revealCorrectWithAI()">✅ 正解を教えて！AIカガワ先生</button>
                </div>
                <div class="wrong-decision-note">※「もう一度解く」を選ぶと，メモを消して解き直せます。</div>
            `;
            feedbackEl.style.display = 'block';
            renderAllMath();
        }

        function retryCurrentQuestion() {
            pendingAIResult = null;

            clearMemo();

            const feedbackEl = document.getElementById('feedback');
            const answerBtn = document.getElementById('answer-btn');
            const indicator = document.getElementById('analyzing-indicator');
            const nextBtn = document.getElementById('next-btn');
            const resultsBtn = document.getElementById('results-btn');

            feedbackEl.style.display = 'none';
            indicator.style.display = 'none';
            nextBtn.style.display = 'none';
            resultsBtn.style.display = 'none';

            answerBtn.textContent = "🤖AIカガワ先生🤖に添削してもらう";
            answerBtn.style.display = 'block';

            showEncouragement();
        }

        function revealCorrectWithAI() {
            if (!pendingAIResult) return;

            const feedbackEl = document.getElementById('feedback');
            const nextBtn = document.getElementById('next-btn');
            const resultsBtn = document.getElementById('results-btn');

            const q = quizData[pendingAIResult.questionIndex] || quizData[currentQuestionIndex];

            if (!incorrectQuestions.includes(q)) {
                incorrectQuestions.push(q);
            }

            let html = `
                <div class="ai-banner">🤖AIカガワ先生🤖の解答check✅</div><br>
                <span style="color: var(--incorrect-color);"><strong>今回は不正解でした。</strong></span><br>
                あなたの解答: ${pendingAIResult.recognizedAnswer || '(読み取り不可)'}<br>
                <strong>正解: </strong><br><img src="${q.answer}" style="max-width: 100%; height: auto; border: 1px solid #ccc; margin: 10px 0;"><br><br>
            `;

            if (pendingAIResult.feedback) {
                html += `${pendingAIResult.feedback}<br>`;
            }

            html += `<hr><div class="explanation-banner">解説</div><br>${q.rationale || ""}`;

            feedbackEl.className = 'incorrect-feedback';
            feedbackEl.innerHTML = html;
            feedbackEl.style.display = 'block';
            renderAllMath();

            if (pendingAIResult.questionIndex < quizData.length - 1) {
                nextBtn.style.display = 'block';
                resultsBtn.style.display = 'none';
            } else {
                nextBtn.style.display = 'none';
                resultsBtn.style.display = 'block';
            }

            pendingAIResult = null;

            saveProgress();
            updateProgressAndScore();
        }

        function validateGraph(userPoints, questionData) {
            if (!questionData.graphTarget) return { isValid: true }; // グラフ問題でなければスルー

            const target = questionData.graphTarget;
            const feedback = [];
            const passedRequiredPoints = [];
            let isValid = true;
            let missingRequired = false;

            // 1. 必須点のチェック (場合分けの端点など)
            if (target.requiredPoints) {
                for (const req of target.requiredPoints) {
                    const match = userPoints.some(p => Math.abs(p.x - req.x) < 0.1 && Math.abs(p.y - req.y) < 0.1);
                    if (!match) {
                        feedback.push(`必須の点 (${req.x}, ${req.y}) がプロットされていません。`);
                        isValid = false;
                        missingRequired = true;
                    } else {
                        passedRequiredPoints.push(`(${req.x}, ${req.y})`);
                    }
                }
            }

            // 2. その他の点の整合性チェック
            for (const p of userPoints) {
                // 必須点リストにある点はスキップ
                const isRequired = target.requiredPoints && target.requiredPoints.some(req => Math.abs(p.x - req.x) < 0.1 && Math.abs(p.y - req.y) < 0.1);

                if (!isRequired && target.isValidPoint) {
                    if (!target.isValidPoint(p.x, p.y)) {
                        feedback.push(`点 (${p.x}, ${p.y}) はグラフ上の点ではありません。`);
                        isValid = false;
                    }
                }
            }

            // 点が少なすぎる場合（例えば1点のみ）
            if (userPoints.length < 2) {
                feedback.push("点を少なくとも2つ以上プロットして、グラフを描いてください。");
                isValid = false;
            }

            return { isValid, feedback: feedback.join('\n'), missingRequired, passedRequiredPoints };
        }

        function promptFactory(currentQuestion, isAnalyzeError = false, systemValidation = null, userPointsData = "") {
            let systemInstruction = "";
            if (systemValidation) {
                const passedInfo = systemValidation.passedRequiredPoints && systemValidation.passedRequiredPoints.length > 0
                    ? `\n- 検出済みの正しい点: ${systemValidation.passedRequiredPoints.join(', ')}`
                    : "";

                if (systemValidation.isValid) {
                    // システム判定が「正解」の場合、AIに反論を許さない
                    systemInstruction = `
【システム判定結果】 ★正解★
・ユーザーのプロットした座標は数学的に全て正しいです。
・「座標が違う」「傾きが違う」といった指摘は**絶対に**しないでください。
・視覚的に多少ズレて見えても、データ上は正確です。
・isCorrect: true を出力してください。
`;
                } else {
                    // システム判定が「不正解」の場合
                    systemInstruction = `
【システム判定結果】 不正解
・システムによる指摘: ${systemValidation.feedback}
・上記のエラーをユーザーに分かりやすく伝えてください。
${passedInfo}
・isCorrect: false を出力してください。
`;
                }
            }

            return `
あなたは高校数学の「関数のグラフ問題」の採点アシスタントです。
画像1: 生徒の手書き解答（座標軸上に描かれたグラフ）
${isAnalyzeError ? "画像2: 正解のグラフ" : "画像2: 正解のグラフ（もし提供されていれば）"}

以下の手順で判定してください。

// システム判定結果
${systemInstruction}

// 【重要】ユーザーが実際にプロットした点の座標データ（システム取得）:
 ${userPointsData}
 // AIはこのデータを「正」として扱い、画像認識よりも優先してください。
 // 例えば、ここに (-1, 2) とあれば、画像でどう見えてもユーザーは (-1, 2) に点を打っています。
 // 逆に、ここに点がない場合は、ユーザーはそこに点を打っていません。

【最重要ルール】
0. 【最重要】画像にユーザーの手書きが全く見当たらない（白紙）場合は、絶対に「不正解」と判定し、isCorrect: false を返してください。「回答が見当たりません」と指摘してください。

1. **基本方針**: メモ帳のグラフ（画像1）に正統のグラフ（画像2）を重ね合わせて採点するイメージで判定してください。
   - **システム判定結果がある場合は、それを最優先してください。** 特に「必須の点がプロットされていない」などの指摘がある場合は、それに従ってください。

2. **採点の優先度**:
   - **最重要1（向き）**: グラフの開く向き（上に凸か下に凸か）が合っているか。**これが逆の場合は、頂点が合っていても必ず「不正解」にしてください。**
   - **最重要2（頂点・端点）**: 折れ曲がる点（頂点）や場合分けの端点が正確か。
   - **重要**: 線分の傾き。

3. 画像1にグラフが描かれていない、または白紙の場合は不正解としてください。

問題: ${currentQuestion.question}

【出力形式】
以下のJSON形式のみを出力してください。Markdownタグは不要です。
{
  "isCorrect": true または false,
  "hasProcessError": false,
  "recognizedAnswer": "画像から読み取ったグラフの特徴（頂点位置や概形など）のみを客観的に記述。正誤判定や「～ではない」といった否定形は含めないこと。例: 'V字型のグラフ。頂点は(1,2)'",
  "feedback": "誤りがある場合の指摘。ユーザーの解答の良い点を認めつつ、間違いを指摘する。システム判定の指摘事項があれば必ず含める。例: '頂点の位置が異なります。正しくは(-1,2)です。'"
}
`;
        }

        async function checkAnswerWithAI() {
            const answerBtn = document.getElementById('answer-btn');
            const indicator = document.getElementById('analyzing-indicator');
            const feedbackEl = document.getElementById('feedback');
            const nextBtn = document.getElementById('next-btn');
            const resultsBtn = document.getElementById('results-btn');

            hideEncouragement();
            pendingAIResult = null;

            answerBtn.style.display = 'none';
            indicator.style.display = 'block';

            // iOS対策: ユーザー操作の直後にAudioContextを再開する
            if (isSoundOn && audioCtx) {
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
            } else if (isSoundOn && !audioCtx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) {
                    audioCtx = new AudioContext();
                    audioCtx.resume();
                }
            }

            const apiKey = localStorage.getItem('gemini_api_key');
            if (!apiKey) {
                alert("APIキーが設定されていません。トップページで設定してください。");
                indicator.style.display = 'none';
                answerBtn.style.display = 'block';
                return;
            }
            // --- 逋ｽ邏吶メ繧ｧ繝・け ---
            const memoPad = document.getElementById('memo-pad');
            if (typeof isCanvasBlank === 'function' && isCanvasBlank(memoPad)) {
                indicator.style.display = 'none';
                playSound('incorrect');

                const feedbackEl = document.getElementById('feedback');

                feedbackEl.className = 'incorrect-feedback';
                feedbackEl.innerHTML = `
                    <div class="ai-banner">🤖AIカガワ先生🤖の解答check✅</div><br>
                    <span style="color: var(--incorrect-color);"><strong>メモが白紙のようです💦</strong></span><br>
                    メモ帳に記述がない場合は分析ができないので，解答はメモ帳に書いてくださいね！<br>
                    <div class="wrong-decision-area">
                        <button class="tool-btn ai-btn wrong-decision-btn" onclick="retryCurrentQuestion()">🔁 もう一度解く</button>
                    </div>
                `;
                feedbackEl.style.display = 'block';
                return;
            }




            const currentQuestion = quizData[currentQuestionIndex];

            try {
                // html2canvasでメモコンテナを画像化
                const memoContainer = document.getElementById('memo-container');
                const capturedCanvas = await html2canvas(memoContainer, {
                    backgroundColor: isDarkMode ? '#121212' : '#ffffff',
                    scale: 2,
                    useCORS: true
                });
                const imageData = capturedCanvas.toDataURL('image/png').split(',')[1];

                // 正解画像の取得
                const correctImageBase64 = window.ANSWER_IMAGES && window.ANSWER_IMAGES[currentQuestion.answer];
                // --- システム判定 (Graph features) ---
                let systemValidation = null;
                if (graphPlotter && graphPlotter.isActive && currentQuestion.graphTarget) {
                    systemValidation = validateGraph(graphPlotter.points, currentQuestion);
                }

                // ユーザーのプロット情報を取得
                let userPointsData = "";
                if (graphPlotter && graphPlotter.isActive && graphPlotter.points.length > 0) {
                    userPointsData = "ユーザーのプロット座標:\n" + graphPlotter.points.map(p => `- (${p.x}, ${p.y})`).join("\n");
                }

                const parts = [
                    { text: promptFactory(currentQuestion, false, systemValidation, userPointsData) },
                    {
                        inline_data: {
                            mime_type: "image/png",
                            data: imageData
                        }
                    }
                ];

                if (correctImageBase64) {
                    const cleanBase64 = correctImageBase64.split(',')[1];
                    parts.push({
                        inline_data: {
                            mime_type: "image/png",
                            data: cleanBase64
                        }
                    });
                }

                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: parts }]
                        })
                    }
                );

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || "API Error");
                }

                const data = await response.json();
                const aiText = data.candidates[0].content.parts[0].text
                    .replace(/```json/g, '')
                    .replace(/```/g, '')
                    .trim();

                const result = parseAIJsonWithRepair(aiText);

                if (result.recognizedAnswer === 'null' || result.recognizedAnswer === null) result.recognizedAnswer = '';
                if (result.feedback === 'null' || result.feedback === null) result.feedback = '';
                if (result.hasProcessError === 'null' || result.hasProcessError === null) result.hasProcessError = false;

                // 不正解なのに誤誘導表現が混ざった場合の安全弁
                const misleading = /(答え|結論)は合って(い|)ます|偶然正解/;
                if (result.isCorrect === false && misleading.test(result.feedback || "")) {
                    result.feedback = "途中の計算や条件の確認が必要です。ゆっくり見直してみましょう。";
                }

                indicator.style.display = 'none';

                if (result.isCorrect) {
                    score++;
                    playSound('correct');

                    // 正解済みなら不正解リストから外す（任意）
                    const idx = incorrectQuestions.indexOf(currentQuestion);
                    if (idx !== -1) incorrectQuestions.splice(idx, 1);

                    feedbackEl.className = 'correct-feedback';

                    const caution = result.hasProcessError
                        ? `<br><span style="color: var(--incorrect-color);"><strong>※答えは合っていますが，途中式に誤りが見られます。</strong></span><br>`
                        : `<br>`;

                    let feedbackHtml =
                        `<div class="ai-banner">🤖AIカガワ先生🤖の解答check✅</div><br>` +
                        `<span style="color: var(--correct-color);"><strong>正解！💐</strong></span>${caution}` +
                        `あなたの解答: ${result.recognizedAnswer || '(読み取り不可)'}<br>`;

                    if (result.feedback) {
                        feedbackHtml += `<br>${result.feedback}<br>`;
                    }

                    feedbackEl.innerHTML = feedbackHtml;

                    saveProgress();
                    updateProgressAndScore();

                    feedbackEl.innerHTML += `<hr><div class="explanation-banner">解説</div><br>${currentQuestion.rationale || ""}`;
                    feedbackEl.style.display = 'block';
                    renderAllMath();

                    if (currentQuestionIndex < quizData.length - 1) {
                        nextBtn.style.display = 'block';
                    } else {
                        resultsBtn.style.display = 'block';
                    }

                } else {
                    playSound('incorrect');

                    // 不正解時は2択を提示（ここではまだ正解も解説も出さない）
                    showWrongDecisionUI(currentQuestion, result);

                    saveProgress();
                    updateProgressAndScore();
                }

            } catch (error) {
                console.error("Gemini API error:", error);
                const msg = String(error.message || '');

                if (
                    msg.includes('Quota exceeded') ||
                    msg.includes('rate limit') ||
                    msg.includes('429')
                ) {
                    alert(
                        "AIの無料利用回数の上限に達しました。\n" +
                        "少し時間をおいてから、もう一度お試しください。"
                    );
                } else {
                    alert("採点中にエラーが発生しました。\n詳細: " + msg);
                }

                indicator.style.display = 'none';
                answerBtn.style.display = 'block';
            }
        }

        function selectAnswer(selectedAnswer, btnElement) {
            // iOS対策: ユーザー操作の直後にAudioContextを再開する
            if (isSoundOn && audioCtx) {
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
            } else if (isSoundOn && !audioCtx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) {
                    audioCtx = new AudioContext();
                    audioCtx.resume();
                }
            }



            const currentQuestion = quizData[currentQuestionIndex];
            const isCorrect = (selectedAnswer === currentQuestion.answer);
            const feedbackEl = document.getElementById('feedback');
            const nextBtn = document.getElementById('next-btn');
            const resultsBtn = document.getElementById('results-btn');

            document.querySelectorAll('.option-btn').forEach(b => b.disabled = true);
            document.getElementById('show-options-btn').style.display = 'none';

            if (isCorrect) {
                score++;
                playSound('correct');
                btnElement.classList.add('correct');
                feedbackEl.className = 'correct-feedback';
                feedbackEl.innerHTML = `<span style="color: var(--correct-color);"><strong>正解！💐</strong></span><br>`;
            } else {
                playSound('incorrect');
                btnElement.classList.add('incorrect', 'selected');
                feedbackEl.className = 'incorrect-feedback';
                feedbackEl.innerHTML = `<span style="color: var(--incorrect-color);"><strong>不正解💦</strong></span><br>（正解: <br><img src="${currentQuestion.answer}" style="max-width: 100%; height: auto; border: 1px solid #ccc; margin: 10px 0;">）<br>`;
            }     // 正解をハイライト
            document.querySelectorAll('.option-btn').forEach(b => {
                if (b.dataset.optionValue === currentQuestion.answer) b.classList.add('correct');
            });

            // ★ AI分析ボタンを追加 (不正解時のみ)
            if (!isCorrect) {
                feedbackEl.innerHTML += `<button class="ai-btn" onclick="checkAnswerWithAI()">🤖 AIカガワ先生に聞く (v2)</button><small> (メモを分析します)<small><br>`;

                // 間違えた問題を記録
                if (!incorrectQuestions.includes(currentQuestion)) {
                    incorrectQuestions.push(currentQuestion);
                }
            }

            saveProgress(); // 進行状況を保存

            updateProgressAndScore();

            // 解説追加
            feedbackEl.innerHTML += currentQuestion.rationale || "";
            feedbackEl.style.display = 'block';
            renderAllMath();

            if (currentQuestionIndex < quizData.length - 1) {
                nextBtn.style.display = 'block';
            } else {
                resultsBtn.style.display = 'block';
            }
        }

        function updateProgressAndScore() {
            document.getElementById('score').textContent = `スコア: ${score} / ${quizData.length}`;
            const progress = (currentQuestionIndex + 1) / quizData.length * 100;
            document.getElementById('progress').style.width = `${progress}%`;
        }

        document.getElementById('next-btn').addEventListener('click', () => {
            currentQuestionIndex++;
            loadQuestion();
        });

        document.getElementById('results-btn').addEventListener('click', () => {
            document.getElementById('quiz-container').style.display = 'none';
            document.getElementById('results-container').style.display = 'block';

            clearProgress(); // 終了したら保存データを削除

            const endTime = Date.now();
            const elapsedSeconds = Math.floor((endTime - startTime) / 1000);
            const minutes = Math.floor(elapsedSeconds / 60);
            const seconds = elapsedSeconds % 60;
            const timeString = `${minutes}分${seconds}秒`;

            const percentage = Math.round((score / quizData.length) * 100);
            document.getElementById('score-text').innerHTML = `${quizData.length} 問中 ${score} 問正解！ (正答率: ${percentage}%)<br>かかった時間: ${timeString}`;

            let msg = "";
            if (percentage === 100) {
                msg = "完璧です！";
                confetti({
                    particleCount: 150,
                    spread: 70,
                    origin: { y: 0.6 }
                });
            } else if (percentage >= 80) {
                msg = "素晴らしい！";
                confetti({
                    particleCount: 100,
                    spread: 70,
                    origin: { y: 0.6 }
                });
            } else {
                msg = "復習しましょう。";
            }
            document.getElementById('final-message').textContent = msg;

            // リトライボタンの表示制御
            const retryBtn = document.getElementById('retry-btn');
            if (incorrectQuestions.length > 0) {
                retryBtn.style.display = 'inline-block';
                retryBtn.textContent = `🔥 間違えた問題だけリトライ (${incorrectQuestions.length}問)`;
            } else {
                retryBtn.style.display = 'none';
            }
        });

        function retryIncorrect() {
            if (incorrectQuestions.length === 0) return;

            // 間違えた問題だけでクイズを再構成
            quizData = [...incorrectQuestions];
            incorrectQuestions = []; // リセット（リトライ中にさらに間違えたらまた追加されるように）
            currentQuestionIndex = 0;
            score = 0;

            // 画面切り替え
            document.getElementById('results-container').style.display = 'none';
            document.getElementById('quiz-container').style.display = 'block';

            startTime = Date.now(); // リトライ時もタイマーリセット
            loadQuestion();
        }

        function sendResults() {
            // 共通設定から読み込み
            let name = localStorage.getItem('quiz_student_name') || "";
            let GAS_URL = localStorage.getItem('quiz_gas_url') || "";

            const statusEl = document.getElementById('send-status');

            if (!name) {
                alert("お名前が設定されていません。\nトップページ（歯車アイコン）で設定してください。");
                return;
            }

            statusEl.textContent = "送信中...";

            if (!GAS_URL) {
                statusEl.textContent = "⚠ エラー: GAS URLが設定されていません。";
                alert("トップページでGAS URLを設定してください。");
                return;
            }

            const endTime = Date.now();
            const elapsedSeconds = Math.floor((endTime - startTime) / 1000);
            const minutes = Math.floor(elapsedSeconds / 60);
            const seconds = elapsedSeconds % 60;
            const timeString = `${minutes}分${seconds}秒`;

            const data = {
                quizName: document.querySelector('h1').textContent, // タイトルを送信
                name: name,
                score: score,
                total: quizData.length,
                time: timeString
            };

            fetch(GAS_URL, {
                method: 'POST',
                mode: 'no-cors', // CORS回避のためno-cors（レスポンスは読めないが送信はできる）
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            })
                .then(() => {
                    statusEl.textContent = "✅ 送信しました！";
                    statusEl.style.color = "green";
                    // 送信ボタンを無効化して連打防止
                    document.querySelector('button[onclick="sendResults()"]').disabled = true;
                })
                .catch(err => {
                    console.error(err);
                    statusEl.textContent = "❌ 送信に失敗しました。";
                    statusEl.style.color = "red";
                });
        }

        // --- 効果音機能 ---
        function initAudioContext() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) return;

            // Create/Resume AudioContext on user action
            const unlockAudio = () => {
                if (!audioCtx) {
                    audioCtx = new AudioContext();
                }
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }

                // Play silent buffer to force wake up audio engine (iOS fix)
                const buffer = audioCtx.createBuffer(1, 1, 22050);
                const source = audioCtx.createBufferSource();
                source.buffer = buffer;
                source.connect(audioCtx.destination);
                source.start(0);

                // Remove event listeners (only need once)
                document.removeEventListener('click', unlockAudio);
                document.removeEventListener('touchstart', unlockAudio);
                document.removeEventListener('keydown', unlockAudio);
            };

            document.addEventListener('click', unlockAudio);
            document.addEventListener('touchstart', unlockAudio);
            document.addEventListener('keydown', unlockAudio);
        }

        function toggleSound() {
            isSoundOn = !isSoundOn;
            const btn = document.getElementById('sound-toggle');
            btn.textContent = isSoundOn ? '🔊' : '🔇';
        }

        function playSound(type) {
            if (!isSoundOn) return;

            // Try to create/resume AudioContext if missing or closed
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) return;

            if (!audioCtx) {
                audioCtx = new AudioContext();
            }

            if (audioCtx.state === 'suspended') {
                audioCtx.resume().catch(e => console.log("Audio resume failed:", e));
            }

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.connect(gain);
            gain.connect(audioCtx.destination);

            if (type === 'correct') {
                // Ping-pong (high pitch x2)
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1000, audioCtx.currentTime);
                osc.frequency.setValueAtTime(1500, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'incorrect') {
                // Buzzer (low saw wave)
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(100, audioCtx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);
            }
        }

        // --- キャンバス機能 ---
        // --- 逋ｽ邏吝愛螳・---
        function isCanvasBlank(canvas) {
            const context = canvas.getContext('2d', { willReadFrequently: true });
            const pixelBuffer = new Uint32Array(
                context.getImageData(0, 0, canvas.width, canvas.height).data.buffer
            );
            return !pixelBuffer.some(color => color !== 0);
        }

        // --- 繧ｭ繝｣繝ｳ繝舌せ讖溯・ ---
        function initCanvas() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());

            if (window.PointerEvent) {
                // Pointer Events (モダンブラウザ・タブレット向け)
                canvas.addEventListener('pointerdown', (e) => {
                    e.preventDefault();
                    if (isPenOnlyMode && e.pointerType === 'touch') {
                        // e.preventDefault(); // This was already here, but moved to the top
                        return;
                    }
                    canvas.setPointerCapture(e.pointerId);
                    startDrawing(e);
                });
                canvas.addEventListener('pointermove', (e) => {
                    e.preventDefault();
                    if (isPenOnlyMode && e.pointerType === 'touch') {
                        // e.preventDefault(); // This was already here, but moved to the top
                        return;
                    }
                    // if (e.pointerType === 'touch') e.preventDefault(); // This was already here, but moved to the top
                    updateCursor(e);

                    if (graphPlotter && graphPlotter.isActive) {
                        const rect = canvas.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        graphPlotter.handleMove(x, y);
                    } else {
                        draw(e);
                    }
                });
                canvas.addEventListener('pointerup', (e) => {
                    e.preventDefault();
                    canvas.releasePointerCapture(e.pointerId);

                    // グラフモードの確定処理
                    if (graphPlotter && graphPlotter.isActive && isDrawing) {
                        const rect = canvas.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        graphPlotter.handleTap(x, y);
                    }

                    stopDrawing();
                    updateCursor(e);
                });
                canvas.addEventListener('pointerenter', (e) => {
                    if (currentTool === 'eraser') {
                        document.getElementById('eraser-cursor').style.display = 'block';
                    }
                });
                canvas.addEventListener('pointerleave', (e) => {
                    document.getElementById('eraser-cursor').style.display = 'none';
                    if (graphPlotter && graphPlotter.isActive) {
                        // ホバー解除
                        graphPlotter.handleMove(-100, -100); // 画面外座標を送って解除
                    }
                });
                canvas.addEventListener('pointercancel', (e) => {
                    canvas.releasePointerCapture(e.pointerId);
                    stopDrawing();
                });
            } else {
                // フォールバック (古いブラウザ用)
                canvas.addEventListener('mousedown', startDrawing);
                canvas.addEventListener('mousedown', startDrawing);
                canvas.addEventListener('mousemove', (e) => {
                    // フォールバック環境でもグラフホバーに対応
                    if (graphPlotter && graphPlotter.isActive) {
                        const rect = canvas.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        graphPlotter.handleMove(x, y);
                    } else {
                        draw(e);
                    }
                });
                canvas.addEventListener('mouseup', (e) => {
                    // グラフモードの確定処理
                    if (graphPlotter && graphPlotter.isActive && isDrawing) {
                        const rect = canvas.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        graphPlotter.handleTap(x, y);
                    }
                    stopDrawing();
                });
                canvas.addEventListener('mouseout', (e) => {
                    stopDrawing();
                    if (graphPlotter && graphPlotter.isActive) {
                        graphPlotter.handleMove(-100, -100);
                    }
                });

                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (isPenOnlyMode) return;
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent("mousedown", { clientX: touch.clientX, clientY: touch.clientY });
                    canvas.dispatchEvent(mouseEvent);
                }, { passive: false });

                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (isPenOnlyMode) return;
                    // グラフモードの場合はマウスイベントへ変換してホバー（ムーブ）処理させる
                    if (graphPlotter && graphPlotter.isActive) {
                        const touch = e.touches[0];
                        const rect = canvas.getBoundingClientRect();
                        const x = touch.clientX - rect.left;
                        const y = touch.clientY - rect.top;
                        graphPlotter.handleMove(x, y);
                        // グラフモード中は描画しないので return
                        return;
                    }

                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent("mousemove", { clientX: touch.clientX, clientY: touch.clientY });
                    canvas.dispatchEvent(mouseEvent);
                }, { passive: false });

                canvas.addEventListener('touchend', (e) => {
                    if (isPenOnlyMode) return;

                    // グラフモードの確定処理 (Touch)
                    // touchendではclientX/Yが取れない場合があるので、changedTouchesを使う
                    if (graphPlotter && graphPlotter.isActive && isDrawing && e.changedTouches.length > 0) {
                        const touch = e.changedTouches[0];
                        const rect = canvas.getBoundingClientRect();
                        const x = touch.clientX - rect.left;
                        const y = touch.clientY - rect.top;
                        graphPlotter.handleTap(x, y);
                        stopDrawing(); // 明示的に呼ぶ
                        return;
                    }

                    canvas.dispatchEvent(new MouseEvent("mouseup", {}));
                });
            }
        }

        function resizeCanvas() {
            const container = document.getElementById('memo-container');
            // 現在の描画内容を一時保存
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
            if (canvas.width > 0 && canvas.height > 0) {
                tempCtx.drawImage(canvas, 0, 0);
            }

            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;

            // 描画内容を復元
            if (tempCanvas.width > 0 && tempCanvas.height > 0) {
                ctx.drawImage(tempCanvas, 0, 0);
            }
            // グラフモードならグリッド再描画
            if (graphPlotter && graphPlotter.isActive) {
                graphPlotter.origin = { x: canvas.width / 2, y: canvas.height / 2 }; // 原点再計算
                graphPlotter.drawGrid();
                graphPlotter.drawPointsAndLines();
            }
        }

        function startDrawing(e) {
            // グラフモードの場合
            if (graphPlotter && graphPlotter.isActive) {
                const rect = canvas.getBoundingClientRect();
                // PointerEvent/MouseEvent has clientX, safe to use directly or fallback to touch only if necessary.
                // e.clientX is usually available on PointerEvent.
                const cx = (typeof e.clientX !== 'undefined') ? e.clientX : e.touches[0].clientX;
                const cy = (typeof e.clientY !== 'undefined') ? e.clientY : e.touches[0].clientY;

                const x = cx - rect.left;
                const y = cy - rect.top;

                // ★変更: タップ（押し込み）時は確定せず、ホバー状態（ゴースト）の更新のみ行う
                // これにより、ドラッグで位置を合わせて、離したときに確定できる
                graphPlotter.handleMove(x, y);
                isDrawing = true; // ドラッグ操作中フラグを立てる（グラフモード用として流用、または別フラグでも可）
                return;
            }

            saveMemoState(); // 描画開始前に履歴保存
            isDrawing = true;
            draw(e);
        }

        function draw(e) {
            if (!isDrawing) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            ctx.lineCap = 'round';

            if (currentTool === 'pen') {
                ctx.globalCompositeOperation = 'source-over';
                ctx.lineWidth = 3;
                ctx.strokeStyle = currentPenColor;
            } else if (currentTool === 'pen-red') {
                ctx.globalCompositeOperation = 'source-over';
                ctx.lineWidth = 3;
                ctx.strokeStyle = '#ff0000';
            } else if (currentTool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = 20;
                ctx.strokeStyle = 'rgba(0,0,0,1)'; // 色は関係ないが念のため
            }

            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y);
        }

        function stopDrawing() {
            isDrawing = false;
            ctx.beginPath();
            // 描画終了後に設定を戻しておくと安全
            ctx.globalCompositeOperation = 'source-over';
        }

        function updateCursor(e) {
            const cursor = document.getElementById('eraser-cursor');
            if (currentTool === 'eraser') {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // キャンバス内にあるか確認
                if (x >= 0 && x <= rect.width && y >= 0 && y <= rect.height) {
                    cursor.style.display = 'block';
                    cursor.style.left = x + 'px';
                    cursor.style.top = y + 'px';
                } else {
                    cursor.style.display = 'none';
                }
            } else {
                cursor.style.display = 'none';
            }
        }

        function saveMemoState() {
            // 履歴は最大10件まで
            if (memoHistory.length >= 10) {
                memoHistory.shift();
            }
            memoHistory.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
        }

        function undoMemo() {
            // グラフモードの場合
            if (graphPlotter && graphPlotter.isActive) {
                graphPlotter.undo();
                return;
            }

            if (memoHistory.length > 0) {
                const lastState = memoHistory.pop();
                ctx.putImageData(lastState, 0, 0);
            }
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));

            // グラフモード解除の処理
            if (tool !== 'graph' && graphPlotter && graphPlotter.isActive) {
                graphPlotter.deactivate();
                document.getElementById('btn-graph').classList.remove('active');
            }

            if (tool === 'pen') {
                document.getElementById('btn-pen').classList.add('active');
                document.getElementById('eraser-cursor').style.display = 'none';
            } else if (tool === 'pen-red') {
                document.getElementById('btn-pen-red').classList.add('active');
                document.getElementById('eraser-cursor').style.display = 'none';
            } else if (tool === 'eraser') {
                document.getElementById('btn-eraser').classList.add('active');
            } else if (tool === 'graph') {
                document.getElementById('btn-graph').classList.add('active');
                // グラフモード時はページ2（インデックス1）へ遷移
                if (typeof switchPage === 'function') {
                    // 既にページ2にいる場合はリロードしない（無限ループ防止）
                    if (typeof multiPageManager !== 'undefined' && multiPageManager && multiPageManager.currentPageIndex !== 1) {
                        multiPageManager.loadPage(1);
                        return; // ページ遷移が発生した場合は、loadPage側で再度setToolが呼ばれるのでここで終了
                    }
                }
                if (graphPlotter) graphPlotter.activate();
                document.getElementById('eraser-cursor').style.display = 'none';
            }
        }

        function clearMemo() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // グラフモードならプロットデータもリセットし、グリッド再描画
            if (graphPlotter && graphPlotter.isActive) {
                graphPlotter.reset();
                graphPlotter.drawGrid();
            }
        }

        function saveMemo() {
            // html2canvasを使ってメモコンテナ全体（問題文含む）を画像化
            const element = document.getElementById('memo-container');
            const overlay = document.getElementById('memo-question-overlay');
            const wasHidden = (overlay.style.display === 'none' || overlay.style.display === '');

            // 保存時のみ一時的に問題文を表示
            if (wasHidden) {
                overlay.style.display = 'block';
                // 数式などが正しくレンダリングされているか確認（非表示だと崩れることがあるため念のため）
                renderAllMath();
            }

            html2canvas(element, {
                backgroundColor: isDarkMode ? '#121212' : '#ffffff', // 背景色を明示
                scale: 2, // 高解像度で取得
                useCORS: true
            }).then(canvas => {
                // 元の状態に戻す（キャプチャ完了後すぐに戻す）
                if (wasHidden) {
                    overlay.style.display = 'none';
                }

                const now = new Date();
                const dateStr = now.getFullYear() +
                    ('0' + (now.getMonth() + 1)).slice(-2) +
                    ('0' + now.getDate()).slice(-2) + '_' +
                    ('0' + now.getHours()).slice(-2) +
                    ('0' + now.getMinutes()).slice(-2) +
                    ('0' + now.getSeconds()).slice(-2);
                const fileName = `memo_${dateStr}.png`;

                canvas.toBlob(async (blob) => {
                    if (!blob) return;

                    const file = new File([blob], fileName, { type: 'image/png' });

                    // プレビュー表示
                    const previewImg = document.getElementById('preview-image');
                    previewImg.src = URL.createObjectURL(blob);

                    // シェアボタンの表示制御
                    const shareBtn = document.getElementById('preview-share-btn');
                    if (navigator.canShare && navigator.canShare({ files: [file] })) {
                        shareBtn.style.display = 'inline-block';
                        shareBtn.onclick = async () => {
                            try {
                                await navigator.share({
                                    files: [file],
                                    title: 'メモを保存',
                                    text: 'メモ画像を保存します'
                                });
                            } catch (err) {
                                console.log('Share cancelled or failed', err);
                            }
                        };
                    } else {
                        shareBtn.style.display = 'none';
                    }

                    document.getElementById('image-preview-modal').style.display = 'flex';
                });
            });
        }

        function closeImagePreview() {
            document.getElementById('image-preview-modal').style.display = 'none';
            // メモリ解放のためにURLをrevoke（念のため）
            const img = document.getElementById('preview-image');
            if (img.src) URL.revokeObjectURL(img.src);
            img.src = '';
        }

        function downloadImage(canvas, fileName) {
            const link = document.createElement('a');
            link.download = fileName;
            link.href = canvas.toDataURL('image/png');
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function toggleQuestionOverlay() {
            const overlay = document.getElementById('memo-question-overlay');
            const btn = document.getElementById('btn-toggle-question');
            if (overlay.style.display === 'none' || overlay.style.display === '') {
                overlay.style.display = 'block';
                btn.classList.add('active');
                renderAllMath(); // 数式レンダリング
            } else {
                overlay.style.display = 'none';
                btn.classList.remove('active');
            }
        }

        function togglePenOnly() {
            isPenOnlyMode = !isPenOnlyMode;
            const btn = document.getElementById('btn-pen-only');
            if (isPenOnlyMode) {
                btn.innerHTML = '🖊️ ペンのみ';
                btn.classList.add('active');
            } else {
                btn.innerHTML = '🖐️ 手書き';
                btn.classList.remove('active');
            }
        }

        // --- ダークモード機能 ---
        function toggleDarkMode() {
            isDarkMode = !isDarkMode;
            document.body.classList.toggle('dark-mode');
            const btn = document.getElementById('dark-mode-toggle');
            btn.textContent = isDarkMode ? '☀️' : '🌙';

            // 設定を保存
            localStorage.setItem('darkMode', isDarkMode);

            // ペンの色を変更
            currentPenColor = isDarkMode ? '#fff' : '#000';

            // キャンバスの色反転
            invertCanvas();
        }

        function invertCanvas() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                // アルファ値が0でない（描画されている）ピクセルのみ処理
                if (data[i + 3] > 0) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    // グレースケール（黒・白・グレー）の場合のみ反転
                    // これにより赤色などはそのまま維持される
                    if (r === g && g === b) {
                        data[i] = 255 - r;     // R
                        data[i + 1] = 255 - g; // G
                        data[i + 2] = 255 - b; // B
                    }
                }
            }
            ctx.putImageData(imageData, 0, 0);

            // 履歴も反転させる必要があるが、今回は簡易的に履歴をクリアする
            memoHistory = [];
        }

        // --- レジューム機能 ---
        function toggleResume() {
            isResumeOn = !isResumeOn;
            localStorage.setItem('resumeOn', isResumeOn);
            updateResumeButton();

            if (!isResumeOn) {
                clearProgress(); // OFFにしたら保存データも消す（オプション）
            } else {
                saveProgress(); // ONにしたら即保存
            }
        }

        function updateResumeButton() {
            const btn = document.getElementById('resume-toggle');
            if (isResumeOn) {
                btn.textContent = '📂';
                btn.style.opacity = '1';
            } else {
                btn.textContent = '📁'; // 閉じたフォルダなど
                btn.style.opacity = '0.5';
            }
        }

        function saveProgress() {
            if (!isResumeOn) return;

            const data = {
                quizData: quizData,
                currentQuestionIndex: currentQuestionIndex,
                score: score,
                incorrectQuestions: incorrectQuestions,
                startTime: startTime,
                timestamp: Date.now()
            };
            localStorage.setItem('quiz_progress_M1-1-4-11', JSON.stringify(data));
        }

        function restoreProgress(data) {
            // データの復元
            quizData = data.quizData;
            currentQuestionIndex = data.currentQuestionIndex;
            score = data.score;
            incorrectQuestions = data.incorrectQuestions || [];
            startTime = data.startTime || Date.now(); // スタート時間がなければ現在時刻

            loadQuestion();
        }

        function clearProgress() {
            localStorage.removeItem('quiz_progress_M1-1-4-11');
        }

        // --- フルスクリーン機能 ---
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(e => console.log(e));
            } else {
                document.exitFullscreen();
            }
        }

        // フルスクリーン変更イベントの監視（アイコン切り替え用）
        document.addEventListener('fullscreenchange', () => {
            const btn = document.getElementById('fullscreen-toggle');
            if (document.fullscreenElement) {
                btn.textContent = '🗕'; // 縮小アイコン
            } else {
                btn.textContent = '⛶'; // 拡大アイコン
            }
        });

        // --- AI分析 ---
        async function analyzeError() {
            const modal = document.getElementById('ai-modal');
            const content = document.getElementById('ai-content');
            modal.style.display = 'flex';
            content.innerHTML = '<p>AIカガワ先生が分析中・・・<br><span style="font-size:2em;">🤖💭</span></p>';

            const apiKey = localStorage.getItem('gemini_api_key');
            if (!apiKey) {
                content.innerHTML = `
                    <p>APIキーが設定されていません。</p>
                    <p><a href="index.html" target="_blank">トップページ</a>の「APIキー設定」からキーを保存してください。</p>
                    <button class="tool-btn" onclick="closeAiModal()">閉じる</button>
                `;
                return;
            }



            const currentQuestion = quizData[currentQuestionIndex];

            try {
                // html2canvasでメモコンテナを画像化 (背景色も反映される)
                const memoContainer = document.getElementById('memo-container');
                const capturedCanvas = await html2canvas(memoContainer, {
                    backgroundColor: isDarkMode ? '#121212' : '#ffffff',
                    scale: 1, // 分析用なので標準解像度で十分
                    useCORS: true
                });
                const imageData = capturedCanvas.toDataURL('image/png').split(',')[1];
                const correctImageBase64 = window.ANSWER_IMAGES && window.ANSWER_IMAGES[currentQuestion.answer];

                const parts = [
                    { text: promptFactory(currentQuestion, true) },
                    {
                        inline_data: {
                            mime_type: "image/png",
                            data: imageData
                        }
                    }
                ];

                if (correctImageBase64) {
                    const cleanBase64 = correctImageBase64.split(',')[1];
                    parts.push({
                        inline_data: {
                            mime_type: "image/png",
                            data: cleanBase64
                        }
                    });
                }

                // ユーザーの環境で利用可能な gemini-2.0-flash を使用 (v1beta)
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: parts }]
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API Error: ${response.status} - ${errorText}`);
                }

                const data = await response.json();

                // レスポンス構造のチェック
                if (!data.candidates || data.candidates.length === 0 || !data.candidates[0].content) {
                    throw new Error("No candidates returned from API");
                }

                const aiText = data.candidates[0].content.parts[0].text;

                content.innerHTML = `
                    <h4>🤖 AIカガワ先生からのアドバイス</h4>
                    <p>${aiText.replace(/\n/g, '<br>')}</p>
                    <button class="tool-btn" onclick="closeAiModal()">閉じる</button>
                `;

                // KaTeXレンダリングを適用
                renderAllMath();

            } catch (error) {
                console.error(error);
                let errorMsg = "不明なエラーが発生しました。";
                if (error.message.includes("404")) {
                    errorMsg = "モデルが見つかりません (404)。APIキーまたはモデル名を確認してください。";
                } else if (error.message.includes("400")) {
                    errorMsg = "リクエストが不正です (400)。APIキーが無効な可能性があります。";
                } else if (error.message.includes("403")) {
                    errorMsg = "アクセス権限がありません (403)。APIキーを確認してください。";
                } else if (error.message.includes("429")) {
                    errorMsg = "リクエスト回数制限を超えました (429)。しばらく待ってから再試行してください。";
                } else {
                    errorMsg = error.message;
                }

                content.innerHTML = `
                    <p>分析中にエラーが発生しました。</p>
                    <p style="color:red; font-size:0.9em;">${errorMsg}</p>
                    <p>詳細: <span style="font-size:0.8em; color:#666;">${error.message}</span></p>
                    <button class="tool-btn" onclick="closeAiModal()">閉じる</button>
                `;
            }
        }

        function closeAiModal() {
            document.getElementById('ai-modal').style.display = 'none';
        }

        // --- 読み上げ ---
        window.speakRationale = function (btn) {
            if (synth.speaking) { synth.cancel(); return; }
            // 簡易実装
            const text = btn.parentElement.innerText.replace(/🔊/g, '');
            const u = new SpeechSynthesisUtterance(text);
            u.lang = 'ja-JP';
            synth.speak(u);
        };

        function renderAllMath() {
            if (window.renderMathInElement) {
                renderMathInElement(document.body, {
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false }
                    ],
                    throwOnError: false
                });
            }
        }
        // --- リサイザー機能 ---
        const resizer = document.getElementById('resizer');
        const leftPanel = document.getElementById('left-panel');
        const rightPanel = document.getElementById('right-panel');
        let isResizing = false;

        resizer.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizer.classList.add('active');
            document.body.style.cursor = 'col-resize';
            // 選択防止
            document.body.style.userSelect = 'none';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            const containerWidth = document.body.clientWidth;
            const x = e.clientX;
            const leftWidthPercent = (x / containerWidth) * 100;

            if (leftWidthPercent > 10 && leftWidthPercent < 90) {
                leftPanel.style.flex = `0 0 ${leftWidthPercent}vw`;
                leftPanel.style.width = `${leftWidthPercent}vw`;
                rightPanel.style.flex = `0 0 ${100 - leftWidthPercent}vw`;
                rightPanel.style.width = `${100 - leftWidthPercent}vw`;
                // resizeCanvas(); // 描画中のリサイズ負荷軽減のため、ドラッグ中はリサイズしない
            }
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                resizer.classList.remove('active');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                resizeCanvas();
            }
        });

        // タッチ対応
        resizer.addEventListener('touchstart', (e) => {
            isResizing = true;
            resizer.classList.add('active');
        }, { passive: false });

        document.addEventListener('touchmove', (e) => {
            if (!isResizing) return;
            const touch = e.touches[0];
            const containerWidth = document.body.clientWidth;
            const x = touch.clientX;
            const leftWidthPercent = (x / containerWidth) * 100;

            if (leftWidthPercent > 10 && leftWidthPercent < 90) {
                leftPanel.style.flex = `0 0 ${leftWidthPercent}vw`;
                leftPanel.style.width = `${leftWidthPercent}vw`;
                rightPanel.style.flex = `0 0 ${100 - leftWidthPercent}vw`;
                rightPanel.style.width = `${100 - leftWidthPercent}vw`;
                // resizeCanvas(); // 描画中のリサイズ負荷軽減のため、ドラッグ中はリサイズしない
            }
        }, { passive: false });

        document.addEventListener('touchend', () => {
            if (isResizing) {
                isResizing = false;
                resizer.classList.remove('active');
                resizeCanvas();
            }
        });


        // --- キャンバス画像をBase64取得（白紙チェック・クロップ・グレースケール） ---
        function getCanvasImageBase64(scale = 1) {
            if (!canvas) return null;

            // 作業用キャンバスを作成
            const workCanvas = document.createElement('canvas');
            workCanvas.width = canvas.width;
            workCanvas.height = canvas.height;
            const wCtx = workCanvas.getContext('2d', { willReadFrequently: true });

            // 1. 白背景で塗りつぶす (透明な部分を白にする)
            wCtx.fillStyle = '#ffffff';
            wCtx.fillRect(0, 0, workCanvas.width, workCanvas.height);

            // 2. 元のキャンバスを描画
            wCtx.drawImage(canvas, 0, 0);

            // 3. ピクセルデータを取得して「描画範囲」を特定 (クロップ用)
            //    同時にグレースケール化＆コントラスト強調もしてしまっても良いが、
            //    まずはクロップ座標を計算する。
            const imgData = wCtx.getImageData(0, 0, workCanvas.width, workCanvas.height);
            const data = imgData.data;
            let minX = workCanvas.width, minY = workCanvas.height, maxX = 0, maxY = 0;
            let hasDrawing = false;

            // 背景色判定用 (白かどうか)
            // 多少の誤差やアンチエイリアスを考慮し、完全に255でなくても「ほぼ白」なら無視
            const THRESHOLD = 240;

            for (let y = 0; y < workCanvas.height; y++) {
                for (let x = 0; x < workCanvas.width; x++) {
                    const i = (y * workCanvas.width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    // 「黒っぽい」ピクセルがあれば描画とみなす
                    // (R, G, Bがいずれも閾値を下回る場合など)
                    if (r < THRESHOLD || g < THRESHOLD || b < THRESHOLD) {
                        if (x < minX) minX = x;
                        if (x > maxX) maxX = x;
                        if (y < minY) minY = y;
                        if (y > maxY) maxY = y;
                        hasDrawing = true;
                    }
                }
            }

            if (!hasDrawing) {
                // 白紙の場合はそのまま返すか、特定のフラグを立てるが、
                // ここでは「全体」を返してしまう（checkAnswer側で白紙チェックしてもよい）
                return workCanvas.toDataURL('image/png').split(',')[1];
            }

            // マージンを追加
            const PADDING = 20;
            minX = Math.max(0, minX - PADDING);
            minY = Math.max(0, minY - PADDING);
            maxX = Math.min(workCanvas.width, maxX + PADDING);
            maxY = Math.min(workCanvas.height, maxY + PADDING);

            const cropW = maxX - minX;
            const cropH = maxY - minY;

            // 4. クロップした画像を生成
            const cropCanvas = document.createElement('canvas');
            cropCanvas.width = cropW;
            cropCanvas.height = cropH;
            const cCtx = cropCanvas.getContext('2d');

            // 白背景
            cCtx.fillStyle = '#ffffff';
            cCtx.fillRect(0, 0, cropW, cropH);

            // 切り抜き描画
            cCtx.drawImage(workCanvas, minX, minY, cropW, cropH, 0, 0, cropW, cropH);

            // 5. 最終的な画像データを取得
            //    (AIが見やすいようにグレースケール化や2値化をしても良いが、
            //     Geminiはカラー画像でも読めるので、コントラストだけ確保されていればOK)
            return cropCanvas.toDataURL('image/png').split(',')[1];
        }

    </script>
    <!-- Image Preview Modal -->
    <div id="image-preview-modal">
        <img id="preview-image" src="" alt="Memo Preview">
        <p class="save-hint">画像を長押しして「写真」に保存してください</p>
        <div class="modal-controls">
            <button id="preview-share-btn" class="share-btn">共有 / 他のアプリで開く</button>
            <button class="close-btn" onclick="closeImagePreview()">閉じる</button>
        </div>
    </div>
</body>

</html>