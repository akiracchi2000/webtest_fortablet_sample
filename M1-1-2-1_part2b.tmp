
        async function checkAnswerWithAI() {
            const answerBtn = document.getElementById('answer-btn');
            const indicator = document.getElementById('analyzing-indicator');
            const feedbackEl = document.getElementById('feedback');
            const nextBtn = document.getElementById('next-btn');
            const resultsBtn = document.getElementById('results-btn');

            hideEncouragement();
            pendingAIResult = null;

            answerBtn.style.display = 'none';
            indicator.style.display = 'block';

            // iOS対策: ユーザー操作の直後にAudioContextを再開する
            if (isSoundOn && audioCtx) {
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
            } else if (isSoundOn && !audioCtx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) {
                    audioCtx = new AudioContext();
                    audioCtx.resume();
                }
            }

            const apiKey = localStorage.getItem('gemini_api_key');
            if (!apiKey) {
                alert("APIキーが設定されていません。トップページで設定してください。");
                indicator.style.display = 'none';
                answerBtn.style.display = 'block';
                return;
            }
            // --- 白紙チェック ---
            const memoPad = document.getElementById('memo-pad');
            const answerPad = document.getElementById('answer-pad');

            if (isCanvasBlank(memoPad) && isCanvasBlank(answerPad)) {
                indicator.style.display = 'none';
                playSound('incorrect');

                const feedbackEl = document.getElementById('feedback');

                feedbackEl.className = 'incorrect-feedback';
                feedbackEl.innerHTML = `
                    <div class="ai-banner">🤖AIカガワ先生🤖の解答check✅</div><br>
                    <span style="color: var(--incorrect-color);"><strong>メモも解答欄も白紙のようです💦</strong></span><br>
                    解答はメモ帳か解答欄に書いてくださいね！<br>
                    <div class="wrong-decision-area">
                        <button class="tool-btn ai-btn wrong-decision-btn" onclick="retryCurrentQuestion()">🔁 もう一度解く</button>
                    </div>
                `;
                feedbackEl.style.display = 'block';
                return;
            }


            const currentQuestion = quizData[currentQuestionIndex];

            try {
                // html2canvas廃止 -> 直接キャンバスから画像を生成
                const memoImage = getCanvasImageBase64(memoPad, 1);
                const answerImage = getCanvasImageBase64(answerPad, 1);

                const prompt = `
あなたは高校数学の「誤り診断」に特化した添削者です。
以下の問題に対する生徒の解答を読み取り，
最終答案の正誤と，途中式の数学的整合性だけを判定してください。

【入力データについて】
- **1枚目の画像**: 画面上部の「解答欄」（Final Answer）です。
- **2枚目の画像**: 画面下部の「計算用紙」（Scratchpad / Process）です。

【重要確認事項】
- 画像は手書きの文字です。特に**数字の「0」や「6」「8」「9」などの閉じた数字**を注意深く読み取ってください。
- 少し線が離れていたり、かすれていても、数学的な文脈から数字を推測してください。
- 小さな丸や点も「0」や「小数点」の可能性があります。
- **基本判定ルール**:
    - **最終的な正誤判定**は、必ず1枚目の「上の解答欄」の記述に基づいて行ってください。
    - **途中式のチェック**は、2枚目の「下の計算用紙」の記述を見て行ってください。
    - もし解答欄が白紙で、計算用紙のみに答えがある場合は、計算用紙の最後の行を答えとみなして採点しても構いませんが、原則は解答欄を優先します。

問題: ${currentQuestion.question}
正解: ${currentQuestion.answer}
解説(参考): ${currentQuestion.rationale}

【採点者としての前提】
- あなたは「厳密さを重視する高校数学教師」です。
- 生徒を責めるのではなく，短くやさしいコメントで誤りの種類や原因を伝えますが，
  正誤や途中式の判定そのものは甘くしてはいけません。

【途中式チェックの方針（必ず実行する内部手順。出力には書かない）】
- まず，与えられた「正解」と「解説(参考)」を手がかりに，
  その問題の典型的な模範解答の流れを 3〜6 個程度のステップに
  頭の中で整理しなさい（この内容は出力しない）。
- 次に，生徒の解答を上から順に読み，
  行やまとまりごとに「ステップ」とみなして，前後のつながりを確認しなさい。
- 生徒の各ステップが，「解説(参考)」のどのステップに対応しているかを大まかに対応づけ，
  どの段階でズレ・省略・誤りが生じているかを把握しなさい。
- 各ステップについて，必ず次の 3 点をチェックしなさい：
  1. 数学的に正しい式変形・論理になっているか。
  2. 直前のステップから論理的に導かれているか（飛躍がないか）。
  3. 等式・不等式の場合，同値変形になっているか。
- 解説とは別解であっても，数学的に正しく，条件をきちんと使っていれば問題ありません。
  ただし，条件抜けや論理の飛躍があれば誤りとして扱いなさい。
- 途中に 1 箇所でも，次のようなものがあれば，
  最終答案が正しくても hasProcessError を true としなさい：
  - 明らかな計算ミスや変形ミス
  - 同値でない式変形
  - 条件の見落としや論理の飛躍
  - 矛盾した記述
- 誤った式や前提から出発しているのに，
  その後の計算によりたまたま正しい最終結果に到達している場合は，
  「途中に誤りがあるが結果が偶然一致している状態」とみなし，
  isCorrect は最終答案で判定しつつ，必ず hasProcessError を true とし，
  feedback では「途中に誤りがあるのに結果だけ合っている」ことを短く指摘しなさい。

【解説(参考)の使い方】
- 「解説(参考)」はその問題の正しい解法の一例です。
- 途中式チェックでは，この解説の流れを基準にして，
  生徒がどのステップで
  - 解説と違う計算や変形をしているか
  - 必要な説明や変形を省略しているか
  - 別の方針を取っていて，それが正しいかどうか
  を推測しなさい。
- feedbackを書くときは，可能であれば
  「解説の○○にあたる部分で〜をしていない／別の式を書いているようです」
  のように，解説とのズレを意識した一言を含めなさい（ただし字数は守る）。

【最重要ルール】
0. 【最重要】画像にユーザーの手書きが全く見当たらない（白紙）場合は、絶対に「不正解」と判定し、isCorrect: false を返してください。「回答が見当たりません」と指摘してください。
1. 画像に何も書かれていない，または白紙に近い場合は必ず不正解とする。
2. その場合は以下のJSONのみを出力して終了する：
   {"isCorrect": false, "hasProcessError": false, "recognizedAnswer": "", "feedback": "メモ帳に記述がない場合は分析ができないので，解答はメモ帳に書いてくださいね！"}
3. 最終答案が正解と一致している場合のみ isCorrect を true とする。
   - 有理化で同じ，同値変形，積の順序違いなどは正解扱い。
   - 途中式に誤りがあるかどうかは isCorrect ではなく hasProcessError で判定し，
     誤りがあれば必ず hasProcessError を true にすること。
4. 途中式が存在する場合は，必ず全ての途中式の整合性をチェックする。
   - 1 行ごと，または意味のまとまりごとに，「前の行と論理的につながっているか」
     「左辺と右辺が本当に等しいか／同値か」を確認する。
5. 最終答案が正解でも途中式に数学的な誤りや飛躍がある場合，
   hasProcessError を true とし，
   feedback で短く指摘する。
   - 1 回でもあれば，
     「細かいからいいか」と見逃さずに hasProcessError を true にする。
6. 途中式がほぼ無い，または文字がつぶれて読めない場合は，
   hasProcessError を false にしてよいが，
   feedback に「途中式が読み取れないため過程の検証は不十分」と短く書く。
7. 間違いの要因として「計算ミス」だけでなく
   「数式の写し間違い（問題文の式や条件の転記ミス）」も重要な誤りとして扱う。
   - 特に，問題文の式や条件を書き写している最初の数行については，
     符号・係数・指数・不等号の向きなどの違いがないかを優先的にチェックし，
     誤りがあれば「写し間違い」として指摘する。
8. 正誤判定問題（答えが「正しい」「正しくない」の場合）について:
   - 漢字の崩れやひらがな表記（例：「ただしい」）でも意図が明確なら採点する。
   - 「〇」「×」はそれぞれ「正しい」「正しくない」に対応させて採点する。
9. 数式は必ずLaTeX形式（$...$）で記述する。分数は \\\\frac{a}{b} を用いる。
   集合記号（\\\\subset,\\\\subseteq,\\\\supset,\\\\supseteq,\\\\in,\\\\notin,\\\\cup,\\\\cap,\\\\emptyset など）も
   必ず $...$ の中に入れる。
   例：「AはBの部分集合なので $A \\\\subset B$」。
10. JSON出力時、文字列内のバックスラッシュは必ずエスケープして「\\\\」と記述してください。
    （例：「\\\\{」ではなく「\\\\\\\\{」）

【背理法などの証明問題に関する追加ルール】
- 解答が背理法を用いている場合は，次の 4 点を必ず確認しなさい。
  1. 証明したい命題の「否定」を，はっきり仮定しているか。
  2. その仮定のもとで，正しい式変形・論理展開を行っているか。
  3. 仮定と矛盾する内容（大小関係の矛盾，偶奇や整数性の矛盾など）を明確に導いているか。
  4. 「仮定が誤り → 元の命題が成り立つ」という結論を，最後に明示しているか。
- 上のいずれかが欠けている場合は，最終的な結論の文言が正しくても，
  hasProcessError を true とし，論証として不十分であることを feedback で短く指摘しなさい。

【feedbackの書き方（やさしく・原因も意識して短く）】
- 50〜120字程度。
- 指摘は最大2点まで。
- 解説や模範解答の再提示は禁止（解説は別に表示される）。
- できる限り，次の2つをセットで簡潔に書きなさい：
  1. どの行・どの式でどんな誤りがあったか（表面的な誤り）
  2. その背景にありそうな原因の推測（〜かもしれません，もしかして〜など）
- 誤りタイプの例：
  計算ミス／符号ミス／公式の適用条件ミス／同値変形の誤り／論理の飛躍／写し間違い
- 原因が確実に特定できる場合は断定してよいが，
  完全には特定できない場合は，
  「〜かもしれません」「〜の可能性があります」「もしかして〜してしまったかな？」など，
  推測であることが分かるやわらかい表現を用いなさい。
  例：
  - 「2行目で $-3$ を $+3$ としているので符号ミスかもしれません。」
  - 「解説で使っている公式の形をうろ覚えで適用してしまった可能性があります。」
- 不正解の場合は，最も致命的な誤り箇所を優先して指摘し，
  可能であれば「なぜそう書いてしまったか」の推測も一言そえる。
- 正解だが hasProcessError が true の場合は
  「答えは合っていますが，途中式に誤りが見られます。」のように，
  答えは認めつつ過程の問題とその原因の推測を短く指摘する。
- 正解かつ途中式にも問題がない場合のみ，feedback を空文字にする。

【出力】
以下のJSON形式のみを出力してください。Markdownのコードブロックは不要です。
{
  "isCorrect": true または false,
  "hasProcessError": true または false,
  "recognizedAnswer": "画像から読み取った生徒の最終解答（LaTeX $...$）。読み取れない場合は空文字。",
  "feedback": "誤り診断コメント。正解かつ過程も問題なければ空文字。"
}
`;

                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                parts: [
                                    { text: prompt },
                                    {
                                        inline_data: {
                                            mime_type: "image/png",
                                            data: answerImage // 1枚目: 解答欄
                                        }
                                    },
                                    {
                                        inline_data: {
                                            mime_type: "image/png",
                                            data: memoImage // 2枚目: 計算用紙
                                        }
                                    }
                                ]
                            }]
                        })
                    }
                );

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || "API Error");
                }

                const data = await response.json();
                const aiText = data.candidates[0].content.parts[0].text
                    .replace(/```json/g, '')
                    .replace(/```/g, '')
                    .trim();

                const result = parseAIJsonWithRepair(aiText);

                if (result.recognizedAnswer === 'null' || result.recognizedAnswer === null) result.recognizedAnswer = '';
                if (result.feedback === 'null' || result.feedback === null) result.feedback = '';
                if (result.hasProcessError === 'null' || result.hasProcessError === null) result.hasProcessError = false;

                // 不正解なのに誤誘導表現が混ざった場合の安全弁
                const misleading = /(答え|結論)は合って(い|)ます|偶然正解/;
                if (result.isCorrect === false && misleading.test(result.feedback || "")) {
                    result.feedback = "途中の計算や条件の確認が必要です。ゆっくり見直してみましょう。";
                }

                indicator.style.display = 'none';

                if (result.isCorrect) {
                    score++;
                    playSound('correct');

                    // 正解済みなら不正解リストから外す（任意）
                    const idx = incorrectQuestions.indexOf(currentQuestion);
                    if (idx !== -1) incorrectQuestions.splice(idx, 1);

                    feedbackEl.className = 'correct-feedback';

                    const caution = result.hasProcessError
                        ? `<br><span style="color: var(--incorrect-color);"><strong>※答えは合っていますが，途中式に誤りが見られます。</strong></span><br>`
                        : `<br>`;

                    let feedbackHtml =
                        `<div class="ai-banner">🤖AIカガワ先生🤖の解答check✅</div><br>` +
                        `<span style="color: var(--correct-color);"><strong>正解！💐</strong></span>${caution}` +
                        `あなたの解答: ${result.recognizedAnswer || '(読み取り不可)'}<br>`;

                    if (result.feedback) {
                        feedbackHtml += `<br>${result.feedback}<br>`;
                    }

                    feedbackEl.innerHTML = feedbackHtml;

                    saveProgress();
                    updateProgressAndScore();

                    feedbackEl.innerHTML += `<hr><div class="explanation-banner">解説</div><br>${currentQuestion.rationale || ""}`;
                    feedbackEl.style.display = 'block';
                    renderAllMath();

                    if (currentQuestionIndex < quizData.length - 1) {
                        nextBtn.style.display = 'block';
                    } else {
                        resultsBtn.style.display = 'block';
                    }

                } else {
                    playSound('incorrect');

                    // 不正解時は2択を提示（ここではまだ正解も解説も出さない）
                    showWrongDecisionUI(currentQuestion, result);

                    saveProgress();
                    updateProgressAndScore();
                }

            } catch (error) {
                console.error("Gemini API error:", error);
                const msg = String(error.message || '');

                if (
                    msg.includes('Quota exceeded') ||
                    msg.includes('rate limit') ||
                    msg.includes('429')
                ) {
                    alert(
                        "AIの無料利用回数の上限に達しました。\\n" +
                        "少し時間をおいてから、もう一度お試しください。"
                    );
                } else {
                    alert("採点中にエラーが発生しました。\\n詳細: " + msg);
                }

                indicator.style.display = 'none';
                answerBtn.style.display = 'block';
            }
        }

        function selectAnswer(selectedAnswer, btnElement) {
            // iOS対策: ユーザー操作の直後にAudioContextを再開する
            if (isSoundOn && audioCtx) {
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
            } else if (isSoundOn && !audioCtx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) {
                    audioCtx = new AudioContext();
                    audioCtx.resume();
                }
            }

            const currentQuestion = quizData[currentQuestionIndex];
            const isCorrect = (selectedAnswer === currentQuestion.answer);
            const feedbackEl = document.getElementById('feedback');
            const nextBtn = document.getElementById('next-btn');
            const resultsBtn = document.getElementById('results-btn');

            document.querySelectorAll('.option-btn').forEach(b => b.disabled = true);
            document.getElementById('show-options-btn').style.display = 'none';

            if (isCorrect) {
                score++;
                playSound('correct');
                btnElement.classList.add('correct');
                feedbackEl.className = 'correct-feedback';
                feedbackEl.innerHTML = `<span style="color: var(--correct-color);"><strong>正解！💐</strong></span><br>`;
            } else {
                playSound('incorrect');
                btnElement.classList.add('incorrect', 'selected');
                feedbackEl.className = 'incorrect-feedback';
                feedbackEl.innerHTML = `<span style="color: var(--incorrect-color);"><strong>不正解💦</strong></span><br>（正解: ${currentQuestion.answer}）<br>`;
            }     // 正解をハイライト
            document.querySelectorAll('.option-btn').forEach(b => {
                if (b.dataset.optionValue === currentQuestion.answer) b.classList.add('correct');
            });

            // ★ AI分析ボタンを追加 (不正解時のみ)
            if (!isCorrect) {
                 feedbackEl.innerHTML += `<button class="ai-btn" onclick="checkAnswerWithAI()">🤖 AIカガワ先生に聞く (v2)</button><small> (メモを分析します)<small><br>`;

                // 間違えた問題を記録
                if (!incorrectQuestions.includes(currentQuestion)) {
                    incorrectQuestions.push(currentQuestion);
                }
            }

            saveProgress(); // 進行状況を保存

            updateProgressAndScore();

            // 解説追加
            feedbackEl.innerHTML += currentQuestion.rationale || "";
            feedbackEl.style.display = 'block';
            renderAllMath();

            if (currentQuestionIndex < quizData.length - 1) {
                nextBtn.style.display = 'block';
            } else {
                resultsBtn.style.display = 'block';
            }
        }

        function updateProgressAndScore() {
            document.getElementById('score').textContent = `スコア: ${score} / ${quizData.length}`;
            const progress = (currentQuestionIndex + 1) / quizData.length * 100;
            document.getElementById('progress').style.width = `${progress}%`;
        }

        document.getElementById('next-btn').addEventListener('click', () => {
            currentQuestionIndex++;
            loadQuestion();
        });

        document.getElementById('results-btn').addEventListener('click', () => {
            document.getElementById('quiz-container').style.display = 'none';
            document.getElementById('results-container').style.display = 'block';

            clearProgress(); // 終了したら保存データを削除

            const endTime = Date.now();
            const elapsedSeconds = Math.floor((endTime - startTime) / 1000);
            const minutes = Math.floor(elapsedSeconds / 60);
            const seconds = elapsedSeconds % 60;
            const timeString = `${minutes}分${seconds}秒`;

            const percentage = Math.round((score / quizData.length) * 100);
            document.getElementById('score-text').innerHTML = `${quizData.length} 問中 ${score} 問正解！ (正答率: ${percentage}%)<br>かかった時間: ${timeString}`;

            let msg = "";
            if (percentage === 100) {
                msg = "完璧です！";
                confetti({
                    particleCount: 150,
                    spread: 70,
                    origin: { y: 0.6 }
                });
            } else if (percentage >= 80) {
                msg = "素晴らしい！";
                confetti({
                    particleCount: 100,
                    spread: 70,
                    origin: { y: 0.6 }
                });
            } else {
                msg = "復習しましょう。";
            }
            document.getElementById('final-message').textContent = msg;

            // リトライボタンの表示制御
            const retryBtn = document.getElementById('retry-btn');
            if (incorrectQuestions.length > 0) {
                retryBtn.style.display = 'inline-block';
                retryBtn.textContent = `🔥 間違えた問題だけリトライ (${incorrectQuestions.length}問)`;
            } else {
                retryBtn.style.display = 'none';
            }
        });

        function retryIncorrect() {
            if (incorrectQuestions.length === 0) return;

            // 間違えた問題だけでクイズを再構成
            quizData = [...incorrectQuestions];
            incorrectQuestions = []; // リセット（リトライ中にさらに間違えたらまた追加されるように）
            currentQuestionIndex = 0;
            score = 0;

            // 画面切り替え
            document.getElementById('results-container').style.display = 'none';
            document.getElementById('quiz-container').style.display = 'block';

            startTime = Date.now(); // リトライ時もタイマーリセット
            loadQuestion();
        }

        function sendResults() {
            // 共通設定から読み込み
            let name = localStorage.getItem('quiz_student_name') || "";
            let GAS_URL = localStorage.getItem('quiz_gas_url') || "";

            const statusEl = document.getElementById('send-status');

            if (!name) {
                alert("お名前が設定されていません。\nトップページ（歯車アイコン）で設定してください。");
                return;
            }

            statusEl.textContent = "送信中...";

            if (!GAS_URL) {
                statusEl.textContent = "⚠️ エラー: GAS URLが設定されていません。";
                alert("トップページでGAS URLを設定してください。");
                return;
            }

            const endTime = Date.now();
            const elapsedSeconds = Math.floor((endTime - startTime) / 1000);
            const minutes = Math.floor(elapsedSeconds / 60);
            const seconds = elapsedSeconds % 60;
            const timeString = `${minutes}分${seconds}秒`;

            const data = {
                quizName: document.querySelector('h1').textContent, // タイトルを送信
                name: name,
                score: score,
                total: quizData.length,
                time: timeString
            };

            fetch(GAS_URL, {
                method: 'POST',
                mode: 'no-cors', // CORS回避のためno-cors（レスポンスは読めないが送信はできる）
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            })
                .then(() => {
                    statusEl.textContent = "✅ 送信しました！";
                    statusEl.style.color = "green";
                    // 送信ボタンを無効化して連打防止
                    document.querySelector('button[onclick="sendResults()"]').disabled = true;
                })
                .catch(err => {
                    console.error(err);
                    statusEl.textContent = "❌ 送信に失敗しました。";
                    statusEl.style.color = "red";
                });
        }

        // --- 効果音機能 ---
        function initAudioContext() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) return;

            // Create/Resume AudioContext on user action
            const unlockAudio = () => {
                if (!audioCtx) {
                    audioCtx = new AudioContext();
                }
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }

                // Play silent buffer to force wake up audio engine (iOS fix)
                const buffer = audioCtx.createBuffer(1, 1, 22050);
                const source = audioCtx.createBufferSource();
                source.buffer = buffer;
                source.connect(audioCtx.destination);
                source.start(0);

                // Remove event listeners (only need once)
                document.removeEventListener('click', unlockAudio);
                document.removeEventListener('touchstart', unlockAudio);
                document.removeEventListener('keydown', unlockAudio);
            };

            document.addEventListener('click', unlockAudio);
            document.addEventListener('touchstart', unlockAudio);
            document.addEventListener('keydown', unlockAudio);
        }

        function toggleSound() {
            isSoundOn = !isSoundOn;
            const btn = document.getElementById('sound-toggle');
            btn.textContent = isSoundOn ? '🔊' : '🔇';
        }

        function playSound(type) {
            if (!isSoundOn) return;

            // Try to create/resume AudioContext if missing or closed
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) return;

            if (!audioCtx) {
                audioCtx = new AudioContext();
            }

            if (audioCtx.state === 'suspended') {
                audioCtx.resume().catch(e => console.log("Audio resume failed:", e));
            }

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.connect(gain);
            gain.connect(audioCtx.destination);

            if (type === 'correct') {
                // Ping-pong (high pitch x2)
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1000, audioCtx.currentTime);
                osc.frequency.setValueAtTime(1500, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'incorrect') {
                // Buzzer (low saw wave)
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(100, audioCtx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);
            }
        }

        // --- 白紙判定 ---
        function isCanvasBlank(canvas) {
            const context = canvas.getContext('2d', { willReadFrequently: true });
            const pixelBuffer = new Uint32Array(
                context.getImageData(0, 0, canvas.width, canvas.height).data.buffer
            );
            return !pixelBuffer.some(color => color !== 0);
        }

        // --- キャンバス機能 ---
        function initCanvases() {
            setupDrawingCanvas(document.getElementById('memo-pad'), true);
            setupDrawingCanvas(document.getElementById('answer-pad'), false);
            window.addEventListener('resize', resizeCanvases);
            resizeCanvases(); // 初期サイズ設定
        }

        function resizeCanvases() {
            resizeCanvasElement(document.getElementById('memo-pad'));
            resizeCanvasElement(document.getElementById('answer-pad'));
        }

        function resizeCanvasElement(canvas) {
            if (!canvas) return;
            const dpr = window.devicePixelRatio || 1;

            // 現在の描画内容を一時保存
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            if (canvas.width > 0 && canvas.height > 0) {
                tempCtx.drawImage(canvas, 0, 0);
            }

            // コンテナのサイズを取得
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();

            // キャンバスの実サイズをDPIに合わせて設定
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;

            // CSSサイズはコンテナに合わせる
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;

            const ctx = canvas.getContext('2d');

            // コンテキストのスケールを設定
            // これにより、以後の描画座標（CSSピクセル単位）が自動的にDPIに合わせて拡大される
            ctx.scale(dpr, dpr);

            // 描画内容を復元 (ピクセル等倍で書き戻す)
            if (tempCanvas.width > 0 && tempCanvas.height > 0) {
                ctx.save();
                ctx.resetTransform(); // スケールを一時的に解除
                ctx.drawImage(tempCanvas, 0, 0);
                ctx.restore();
            }
        }

        function startDrawing(e) {
            const canvas = e.target;
            if (!canvas.ctx) return;
            canvas.isDrawing = true;
            draw(e);
        }

        function draw(e) {
            const canvas = e.target;
            if (!canvas.isDrawing || !canvas.ctx) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const ctx = canvas.ctx;

            ctx.lineCap = 'round';
            ctx.lineJoin = 'round'; // 角を丸くする

            if (currentTool === 'pen') {
                ctx.globalCompositeOperation = 'source-over';
                ctx.lineWidth = 3;
                ctx.strokeStyle = currentPenColor;
            } else if (currentTool === 'pen-red') {
                ctx.globalCompositeOperation = 'source-over';
                ctx.lineWidth = 3;
                ctx.strokeStyle = '#ff0000';
            } else if (currentTool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = 20;
                ctx.strokeStyle = 'rgba(0,0,0,1)';
            }

            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y);
        }

        function stopDrawing(e) {
            const canvas = e.target;
            if (!canvas) return;
            canvas.isDrawing = false;
            // beginPath は ctx に対して行う必要がある
            if (canvas.ctx) canvas.ctx.beginPath();

            if (canvas.id === 'memo-pad') {
                saveMemoState();
            }
        }

        function clearAnswerPad() {
            const canvas = document.getElementById('answer-pad');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }


        // キャンバスごとの設定
        function setupDrawingCanvas(canvas, enableHistory) {
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            canvas.ctx = ctx; // 要素に紐付け
            canvas.isDrawing = false; // 状態も紐付け

            canvas.addEventListener('contextmenu', (e) => e.preventDefault());

            if (window.PointerEvent) {
                canvas.addEventListener('pointerdown', (e) => {
                    e.preventDefault();
                    if (isPenOnlyMode && e.pointerType === 'touch') return;
                    canvas.setPointerCapture(e.pointerId);
                    startDrawing(e);
                });
                canvas.addEventListener('pointermove', (e) => {
                    e.preventDefault();
                    if (isPenOnlyMode && e.pointerType === 'touch') return;
                    if (e.getCoalescedEvents) {
                        const events = e.getCoalescedEvents();
                        for (const event of events) draw(event);
                    } else {
                        draw(e);
                    }
                    if (canvas.id === 'memo-pad') updateCursor(e);
                });
                canvas.addEventListener('pointerup', (e) => {
                    e.preventDefault();
                    canvas.releasePointerCapture(e.pointerId);
                    stopDrawing(e);
                    if (canvas.id === 'memo-pad') updateCursor(e);
                });
                canvas.addEventListener('pointerenter', (e) => {
                    if (canvas.id === 'memo-pad' && currentTool === 'eraser') {
                        document.getElementById('eraser-cursor').style.display = 'block';
                    }
                });
                canvas.addEventListener('pointerleave', (e) => {
                    document.getElementById('eraser-cursor').style.display = 'none';
                });
                canvas.addEventListener('pointercancel', (e) => {
                    canvas.releasePointerCapture(e.pointerId);
                    stopDrawing(e);
                });
            } else {
                // Fallback
                canvas.addEventListener('mousedown', startDrawing);
                canvas.addEventListener('mousemove', draw);
                canvas.addEventListener('mouseup', stopDrawing);
                canvas.addEventListener('mouseout', stopDrawing);
            }
        }

        function updateCursor(e) {
            const cursor = document.getElementById('eraser-cursor');
            const canvas = e.target;
            if (currentTool === 'eraser' && canvas.id === 'memo-pad') {
                cursor.style.display = 'block';
                const rect = canvas.getBoundingClientRect();
                cursor.style.left = (e.clientX - rect.left) + 'px';
                cursor.style.top = (e.clientY - rect.top) + 'px';
            } else {
                cursor.style.display = 'none';
            }
        }

        function saveMemoState() {
            const canvas = document.getElementById('memo-pad');
            const ctx = canvas.ctx;
            if (!ctx) return;

            // 履歴は最大10件まで
            if (memoHistory.length >= 10) {
                memoHistory.shift();
            }
            memoHistory.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
        }

        function undoMemo() {
            const canvas = document.getElementById('memo-pad');
            const ctx = canvas.ctx;
            if (!ctx) return;

            if (memoHistory.length > 0) {
                const lastState = memoHistory.pop();
                ctx.putImageData(lastState, 0, 0);
            }
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            if (tool === 'pen') {
                document.getElementById('btn-pen').classList.add('active');
                document.getElementById('eraser-cursor').style.display = 'none';
            } else if (tool === 'pen-red') {
                document.getElementById('btn-pen-red').classList.add('active');
                document.getElementById('eraser-cursor').style.display = 'none';
            } else if (tool === 'eraser') {
                document.getElementById('btn-eraser').classList.add('active');
            }
        }

        function clearMemo() {
            const canvas = document.getElementById('memo-pad');
            const ctx = canvas.getContext('2d'); // or canvas.ctx
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function saveMemo() {
            // html2canvasを使ってメモコンテナ全体（問題文含む）を画像化
            const element = document.getElementById('memo-container');
            const overlay = document.getElementById('memo-question-overlay');
            const wasHidden = (overlay.style.display === 'none' || overlay.style.display === '');

            // 保存時のみ一時的に問題文を表示
            if (wasHidden) {
                overlay.style.display = 'block';
                // 数式などが正しくレンダリングされているか確認（非表示だと崩れることがあるため念のため）
                renderAllMath();
            }

            html2canvas(element, {
                backgroundColor: isDarkMode ? '#121212' : '#ffffff', // 背景色を明示
                scale: 2 // 高解像度で取得
            }).then(canvas => {
                // 元の状態に戻す（キャプチャ完了後すぐに戻す）
                if (wasHidden) {
                    overlay.style.display = 'none';
                }

                const now = new Date();
                const dateStr = now.getFullYear() +
                    ('0' + (now.getMonth() + 1)).slice(-2) +
                    ('0' + now.getDate()).slice(-2) + '_' +
                    ('0' + now.getHours()).slice(-2) +
                    ('0' + now.getMinutes()).slice(-2) +
                    ('0' + now.getSeconds()).slice(-2);
                const fileName = `memo_${dateStr}.png`;

                canvas.toBlob(async (blob) => {
                    if (!blob) return;

                    const file = new File([blob], fileName, { type: 'image/png' });

                    // プレビュー表示
                    const previewImg = document.getElementById('preview-image');
                    previewImg.src = URL.createObjectURL(blob);

                    // シェアボタンの表示制御
                    const shareBtn = document.getElementById('preview-share-btn');
                    if (navigator.canShare && navigator.canShare({ files: [file] })) {
                        shareBtn.style.display = 'inline-block';
                        shareBtn.onclick = async () => {
                            try {
                                await navigator.share({
                                    files: [file],
                                    title: 'メモを保存',
                                    text: 'メモ画像を保存します'
                                });
                            } catch (err) {
                                console.log('Share cancelled or failed', err);
                            }
                        };
                    } else {
                        shareBtn.style.display = 'none';
                    }

                    document.getElementById('image-preview-modal').style.display = 'flex';
                });
            });
        }

        function closeImagePreview() {
            document.getElementById('image-preview-modal').style.display = 'none';
            // メモリ解放のためにURLをrevoke（念のため）
            const img = document.getElementById('preview-image');
            if (img.src) URL.revokeObjectURL(img.src);
            img.src = '';
        }

        function downloadImage(canvas, fileName) {
            const link = document.createElement('a');
            link.download = fileName;
            link.href = canvas.toDataURL('image/png');
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function toggleQuestionOverlay() {
            const overlay = document.getElementById('memo-question-overlay');
            const btn = document.getElementById('btn-toggle-question');
            if (overlay.style.display === 'none' || overlay.style.display === '') {
                overlay.style.display = 'block';
                btn.classList.add('active');
                renderAllMath(); // 数式レンダリング
            } else {
                overlay.style.display = 'none';
                btn.classList.remove('active');
            }
        }

        function togglePenOnly() {
            isPenOnlyMode = !isPenOnlyMode;
            const btn = document.getElementById('btn-pen-only');
            if (isPenOnlyMode) {
                btn.innerHTML = '🖊️ ペンのみ';
                btn.classList.add('active');
            } else {
                btn.innerHTML = '🖐️ 手書き';
                btn.classList.remove('active');
            }
        }

        // --- ダークモード機能 ---
        function toggleDarkMode() {
            isDarkMode = !isDarkMode;
            document.body.classList.toggle('dark-mode');
            const btn = document.getElementById('dark-mode-toggle');
            btn.textContent = isDarkMode ? '☀️' : '🌙';

            // 設定を保存
            localStorage.setItem('darkMode', isDarkMode);

            // ペンの色を変更
            currentPenColor = isDarkMode ? '#fff' : '#000';

            // キャンバスの色反転
            invertCanvasColors(document.getElementById('memo-pad'));
            invertCanvasColors(document.getElementById('answer-pad'));
        }

        function invertCanvasColors(canvas) {
            if (!canvas) return;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                // アルファ値が0でない（描画されている）ピクセルのみ処理
                if (data[i + 3] > 0) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    // グレースケール（黒・白・グレー）の場合のみ反転
                    // これにより赤色などはそのまま維持される
                    if (r === g && g === b) {
                        data[i] = 255 - r;     // R
                        data[i + 1] = 255 - g; // G
                        data[i + 2] = 255 - b; // B
                    }
                }
            }
            ctx.putImageData(imageData, 0, 0);

            // 履歴も反転させる必要があるが、今回は簡易的に履歴をクリアする
            // (MemoPadのみ履歴があるのでチェック)
            if (canvas.id === 'memo-pad') {
                memoHistory = [];
            }
        }

        // --- レジューム機能 ---
        function toggleResume() {
            isResumeOn = !isResumeOn;
            localStorage.setItem('resumeOn', isResumeOn);
            updateResumeButton();

            if (!isResumeOn) {
                clearProgress(); // OFFにしたら保存データも消す（オプション）
            } else {
                saveProgress(); // ONにしたら即保存
            }
        }

        function updateResumeButton() {
            const btn = document.getElementById('resume-toggle');
            if (isResumeOn) {
                btn.textContent = '📂';
                btn.style.opacity = '1';
            } else {
                btn.textContent = '📁'; // 閉じたフォルダなど
                btn.style.opacity = '0.5';
            }
        }

        function saveProgress() {
            if (!isResumeOn) return;

            const data = {
                quizData: quizData,
                currentQuestionIndex: currentQuestionIndex,
                score: score,
                incorrectQuestions: incorrectQuestions,
                startTime: startTime,
                timestamp: Date.now()
            };
            localStorage.setItem('quiz_progress_M1-1-2-1', JSON.stringify(data));
        }

        function restoreProgress(data) {
            // データの復元
            quizData = data.quizData;
            currentQuestionIndex = data.currentQuestionIndex;
            score = data.score;
            incorrectQuestions = data.incorrectQuestions || [];
            startTime = data.startTime || Date.now(); // スタート時間がなければ現在時刻

            loadQuestion();
        }

        function clearProgress() {
            localStorage.removeItem('quiz_progress_M1-1-2-1');
        }

        // --- フルスクリーン機能 ---
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(e => console.log(e));
            } else {
                document.exitFullscreen();
            }
        }

        // フルスクリーン変更イベントの監視（アイコン切り替え用）
        document.addEventListener('fullscreenchange', () => {
            const btn = document.getElementById('fullscreen-toggle');
            if (document.fullscreenElement) {
                btn.textContent = '🗕'; // 縮小アイコン
            } else {
                btn.textContent = '⛶'; // 拡大アイコン
            }
        });

        // --- AI分析 ---
        async function analyzeError() {
            const modal = document.getElementById('ai-modal');
            const content = document.getElementById('ai-content');
            modal.style.display = 'flex';
            content.innerHTML = '<p>AIカガワ先生が分析中・・・<br><span style="font-size:2em;">🤖💭</span></p>';

            const apiKey = localStorage.getItem('gemini_api_key');
            if (!apiKey) {
                content.innerHTML = `
                    <p>APIキーが設定されていません。</p>
                    <p><a href="index.html" target="_blank">トップページ</a>の「APIキー設定」からキーを保存してください。</p>
                    <button class="tool-btn" onclick="closeAiModal()">閉じる</button>
                `;
                return;
            }

            const currentQuestion = quizData[currentQuestionIndex];

            try {
                // html2canvas廃止 -> 直接キャンバスから画像を生成
                const imageData = getCanvasImageBase64(1);

                const prompt = `
あなたは高校数学の「誤り診断」に特化した添削者です。
以下の問題に対する生徒の手書き解答（画像）を読み取り，
最終答案の正誤と，途中式の数学的整合性だけを判定してください。

【重要確認事項】
- 画像は手書きの文字です。特に**数字の「0」や「6」「8」「9」などの閉じた数字**を注意深く読み取ってください。
- 少し線が離れていたり、かすれていても、数学的な文脈から数字を推測してください。
- 小さな丸や点も「0」や「小数点」の可能性があります。

問題: ${currentQuestion.question}
正解: ${currentQuestion.answer}

【最重要ルール】
0. 【最重要】画像にユーザーの手書きが全く見当たらない（白紙）場合は、絶対に「不正解」と判定し、isCorrect: false を返してください。「回答が見当たりません」と指摘してください。
1. 画像に何も書かれていない，または白紙に近い場合は必ず不正解とする。
2. その場合は以下のJSONのみを出力して終了する：
   {"isCorrect": false, "hasProcessError": false, "recognizedAnswer": "", "feedback": "メモ帳に記述がない場合は分析ができないので，解答はメモ帳に書いてくださいね！"}
3. 最終答案が正解と一致している場合のみ isCorrect を true とする。
   - 有理化で同じ，同値変形，積の順序違いなどは正解扱い。
4. 途中式が存在する場合は，必ず途中式の整合性をチェックする。
5. 最終答案が正解でも途中式に数学的な誤りや飛躍がある場合，
   hasProcessError を true とし，
   feedback で短く指摘する。
6. 途中式がほぼ無い/読めない場合は hasProcessError を false にしてよいが，
   feedback に「途中式が読み取れないため過程の検証は不十分」と短く書く。
7. 間違いの要因として「計算ミス」だけでなく
   「数式の写し間違い（問題文の式や条件の転記ミス）」も重要な誤りとして扱い，
   可能なら優先して指摘する。
8. 正誤判定問題（答えが「正しい」「正しくない」の場合）について:
   - 漢字の崩れやひらがな表記（例：「ただしい」）でも意図が明確なら採点。
   - 「〇」「×」はそれぞれ「正しい」「正しくない」に対応させて採点。
9. 数式は必ずLaTeX形式（$...$）で記述する。分数は \\\\frac{a}{b} を用いる。
   集合記号（\\\\subset,\\\\subseteq,\\\\supset,\\\\supseteq,\\\\in,\\\\notin,\\\\cup,\\\\cap,\\\\emptyset など）も
   必ず $...$ の中に入れる。
   例：「AはBの部分集合なので $A \\\\subset B$」。
10. JSON出力時、文字列内のバックスラッシュは必ずエスケープして「\\\\」と記述してください。（例：「\\\\{」ではなく「\\\\\\\\{」）

【feedbackの書き方（やさしく短く）】
- 50〜120字程度。
- 指摘は最大2点まで。
- 解説や模範解答の再提示は禁止（解説は別に表示される）。
- 誤りタイプの例：
  計算ミス／符号ミス／公式の適用条件ミス／同値変形の誤り／論理の飛躍／写し間違い
- 不正解の場合は最も致命的な誤り箇所を優先して指摘。
- 正解だが hasProcessError が true の場合は
  「答えは合っていますが，途中式に誤りが見られます。」のように自然な表現で短く指摘。

【出力】
以下のJSON形式のみを出力してください。Markdownのコードブロックは不要です。
{
  "isCorrect": true または false,
  "hasProcessError": true または false,
  "recognizedAnswer": "画像から読み取った生徒の最終解答（LaTeX $...$）。読み取れない場合は空文字。",
  "feedback": "誤り診断コメント。正解かつ過程も問題なければ空文字。"
}
`;


                // ユーザーの環境で利用可能な gemini-2.0-flash を使用 (v1beta)
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{
                            parts: [
                                { text: prompt },
                                {
                                    inline_data: {
                                        mime_type: "image/png",
                                        data: imageData
                                    }
                                }
                            ]
                        }]
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API Error: ${response.status} - ${errorText}`);
                }

                const data = await response.json();

                // レスポンス構造のチェック
                if (!data.candidates || data.candidates.length === 0 || !data.candidates[0].content) {
                    throw new Error("No candidates returned from API");
                }

                const aiText = data.candidates[0].content.parts[0].text;

                content.innerHTML = `
                    <h4>🤖 AIカガワ先生からのアドバイス</h4>
                    <p>${aiText.replace(/\\n/g, '<br>')}</p>
                    <button class="tool-btn" onclick="closeAiModal()">閉じる</button>
                `;

                // KaTeXレンダリングを適用
                renderAllMath();

            } catch (error) {
                console.error(error);
                let errorMsg = "不明なエラーが発生しました。";

                if (error.message.includes("404")) {
                    errorMsg = "モデルが見つかりません (404)。APIキーまたはモデル名を確認してください。";
                } else if (error.message.includes("400")) {
                    errorMsg = "リクエストが不正です (400)。APIキーが無効な可能性があります。";
                } else if (error.message.includes("403")) {
                    errorMsg = "アクセス権限がありません (403)。APIキーを確認してください。";
                } else if (error.message.includes("429")) {
                    errorMsg = "リクエスト回数制限を超えました (429)。しばらく待ってから再試行してください。";
                } else {
                    errorMsg = error.message;
                }

                content.innerHTML = `
                    <p>分析中にエラーが発生しました。</p>
                    <p style="color:red; font-size:0.9em;">${errorMsg}</p>
                    <p>詳細: <span style="font-size:0.8em; color:#666;">${error.message}</span></p>
                    <button class="tool-btn" onclick="closeAiModal()">閉じる</button>
                `;
            }
        }

        function closeAiModal() {
            document.getElementById('ai-modal').style.display = 'none';
        }

        // --- 読み上げ ---
        window.speakRationale = function (btn) {
            if (synth.speaking) { synth.cancel(); return; }
            // 簡易実装
            const text = btn.parentElement.innerText.replace(/🔊/g, '');
            const u = new SpeechSynthesisUtterance(text);
            u.lang = 'ja-JP';
            synth.speak(u);
        };

        function renderAllMath() {
            if (window.renderMathInElement) {
                renderMathInElement(document.body, {
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false }
                    ],
                    throwOnError: false
                });
            }
        }
        // --- リサイザー機能 ---
        const resizer = document.getElementById('resizer');
        const leftPanel = document.getElementById('left-panel');
        const rightPanel = document.getElementById('right-panel');
        let isResizing = false;

        resizer.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizer.classList.add('active');
            document.body.style.cursor = 'col-resize';
            // 選択防止
            document.body.style.userSelect = 'none';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            const containerWidth = document.body.clientWidth;
            const x = e.clientX;
            const leftWidthPercent = (x / containerWidth) * 100;

            if (leftWidthPercent > 10 && leftWidthPercent < 90) {
                leftPanel.style.flex = `0 0 ${leftWidthPercent}vw`;
                leftPanel.style.width = `${leftWidthPercent}vw`;
                rightPanel.style.flex = `0 0 ${100 - leftWidthPercent}vw`;
                rightPanel.style.width = `${100 - leftWidthPercent}vw`;
                // resizeCanvas(); // 描画中のリサイズ負荷軽減のため、ドラッグ中はリサイズしない
            }
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                resizer.classList.remove('active');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                resizeCanvases();
            }
        });

        // タッチ対応
        resizer.addEventListener('touchstart', (e) => {
            isResizing = true;
            resizer.classList.add('active');
        }, { passive: false });

        document.addEventListener('touchmove', (e) => {
            if (!isResizing) return;
            const touch = e.touches[0];
            const containerWidth = document.body.clientWidth;
            const x = touch.clientX;
            const leftWidthPercent = (x / containerWidth) * 100;

            if (leftWidthPercent > 10 && leftWidthPercent < 90) {
                leftPanel.style.flex = `0 0 ${leftWidthPercent}vw`;
                leftPanel.style.width = `${leftWidthPercent}vw`;
                rightPanel.style.flex = `0 0 ${100 - leftWidthPercent}vw`;
                rightPanel.style.width = `${100 - leftWidthPercent}vw`;
                // resizeCanvas(); // 描画中のリサイズ負荷軽減のため、ドラッグ中はリサイズしない
            }
        }, { passive: false });

        document.addEventListener('touchend', () => {
            if (isResizing) {
                isResizing = false;
                resizer.classList.remove('active');
                resizeCanvases();
            }
        });
